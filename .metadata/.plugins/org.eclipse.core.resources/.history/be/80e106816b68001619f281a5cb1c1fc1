package com.example.test;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.NotificationManager;
import android.appwidget.AppWidgetManager;
import android.content.ActivityNotFoundException;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.PermissionInfo;
import android.content.pm.ResolveInfo;
import android.content.res.AssetManager;
import android.content.res.Resources;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Paint.FontMetrics;
import android.graphics.Rect;
import android.media.MediaScannerConnection;
import android.media.MediaScannerConnection.MediaScannerConnectionClient;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.os.ResultReceiver;
import android.os.StatFs;
import android.os.storage.StorageManager;
import android.preference.PreferenceManager;
import android.provider.ContactsContract;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.DisplayMetrics;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.webkit.MimeTypeMap;
import android.webkit.WebView;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import com.baidu.android.app.account.BoxAccount;
import com.baidu.android.app.account.BoxAccountManager;
import com.baidu.android.app.account.BoxAccountManagerFactory;
import com.baidu.android.app.account.PassSapiHelper;
import com.baidu.android.common.logging.Log;
import com.baidu.android.common.util.APIUtils;
import com.baidu.android.common.util.DeviceId;
import com.baidu.browser.Browser;
import com.baidu.browser.lightapp.LightApp;
import com.baidu.browser.lightapp.open.WebappController;
import com.baidu.browser.sailor.BdSailorWebView;
import com.baidu.browser.sailor.lightapp.BdLightappConstants;
import com.baidu.browser.sailor.util.BdZeusUtil;
import com.baidu.browser.search.LightSearchActivity;
import com.baidu.megapp.ma.MAActivity;
import com.baidu.megapp.pm.MAPackageInfo;
import com.baidu.megapp.pm.MAPackageManager;
import com.baidu.searchbox.BaseActivity;
import com.baidu.searchbox.BuildConfig;
import com.baidu.searchbox.CodeScannerActivity.CodeScannerCaller;
import com.baidu.searchbox.IntentConstants;
import com.baidu.searchbox.LightBrowserPluginStackActivity;
import com.baidu.searchbox.MainActivity;
import com.baidu.searchbox.NBSwitcher;
import com.baidu.searchbox.NoProGuard;
import com.baidu.searchbox.R;
import com.baidu.searchbox.SearchBox;
import com.baidu.searchbox.VoiceSearch;
import com.baidu.searchbox.account.im.GroupInfoManager;
import com.baidu.searchbox.account.userinfo.AccountUserInfoManager;
import com.baidu.searchbox.aps.base.db.PluginCache;
import com.baidu.searchbox.aps.center.install.api.PluginInstallManager;
import com.baidu.searchbox.barcode.entry.CodeScannerActivity;
import com.baidu.searchbox.barcode.entry.ResultHandler;
import com.baidu.searchbox.barcode.entry.ResultHandlerInterface;
import com.baidu.searchbox.barcode.entry.ResultViewHandlerImpl;
import com.baidu.searchbox.bookmark.BookmarkHistoryActivity;
import com.baidu.searchbox.bookmark.Bookmarks.BookmarkItemData;
import com.baidu.searchbox.browser.SearchBrowser;
import com.baidu.searchbox.browser.WebAddress;
import com.baidu.searchbox.card.util.CardConstants;
import com.baidu.searchbox.command.CommandUtils;
import com.baidu.searchbox.common.util.StreamUtils;
import com.baidu.searchbox.common.util.UrlUtil;
import com.baidu.searchbox.config.AppConfig;
import com.baidu.searchbox.database.OEMConfiguartion;
import com.baidu.searchbox.developer.ui.DebugFeturesTab;
import com.baidu.searchbox.domesticservice.DomesticServiceManager;
import com.baidu.searchbox.downloads.DownloadService;
import com.baidu.searchbox.feedback.FeedbackInfoManager;
import com.baidu.searchbox.feedback.onekey.OnekeyUploadActivity;
import com.baidu.searchbox.home.HomeTabHostView;
import com.baidu.searchbox.home.tabs.HomeTabManager;
import com.baidu.searchbox.http.ConnectManager;
import com.baidu.searchbox.lib.ShareUtils;
import com.baidu.searchbox.lib.XSearchUtils;
import com.baidu.searchbox.lib.widget.BaseWebView;
import com.baidu.searchbox.lib.widget.BaseWebView.ActivityNotStartedException;
import com.baidu.searchbox.lightbrowser.LightBrowserActivity;
import com.baidu.searchbox.location.SearchBoxLocationManager;
import com.baidu.searchbox.net.ProxyHttpClient;
import com.baidu.searchbox.net.SearchBoxCookieUtils;
import com.baidu.searchbox.plugin.api.BarcodePluginManager;
import com.baidu.searchbox.plugins.PluginBarcodeActivity;
import com.baidu.searchbox.plugins.annotation.PluginAccessable;
import com.baidu.searchbox.plugins.utils.LocalLogTracker;
import com.baidu.searchbox.plugins.utils.PluginLoadManager;
import com.baidu.searchbox.plugins.utils.PluginStatistic;
import com.baidu.searchbox.qrcode.Barcode;
import com.baidu.searchbox.qrcode.BarcodeResult;
import com.baidu.searchbox.qrcode.BarcodeType;
import com.baidu.searchbox.schemedispatch.SchemeUtility;
import com.baidu.searchbox.search.SearchManager;
import com.baidu.searchbox.service.CommonIntentService;
import com.baidu.searchbox.statistic.StatisticConstants;
import com.baidu.searchbox.statistic.StatisticProcessor;
import com.baidu.searchbox.ui.FloatSearchBoxLayout;
import com.baidu.searchbox.ui.TargetView;
import com.baidu.searchbox.util.algorithm.GZIP;
import com.baidu.searchbox.video.history.VideoPlayHistoryItemInfo;
import com.baidu.searchbox.video.player.AbsVideoPlayer;
import com.baidu.searchbox.video.player.IVideoPlayer;
import com.baidu.searchbox.video.player.PluginVideoPlayInfo;
import com.baidu.searchbox.video.player.VideoPlayerFactory;
import com.baidu.searchbox.video.plugin.model.BdVideo;
import com.baidu.searchbox.video.util.VideoPlayUtil;
import com.baidu.searchbox.wallet.WalletBrowserActivity;
import com.baidu.searchbox.wallet.WalletManager;
import com.baidu.searchbox.wallet.data.WalletCommandHandler;
import com.baidu.searchbox.wallet.data.WalletConstants;
import com.baidu.searchbox.wallet.data.WalletQrListGrabber;
import com.baidu.searchbox.widget.ClockWidgetProvider;
import com.baidu.searchbox.widget.DingWidget;
import com.baidu.ubc.UBC;
import com.baidu.wallet.api.BaiduWalletPluginManagerProxy;
import com.baidu.webkit.sdk.BCookieManager;
import com.google.zxing.searchbox.Result;
import com.google.zxing.searchbox.client.result.EmailAddressParsedResult;
import com.google.zxing.searchbox.client.result.ParsedResult;
import com.google.zxing.searchbox.client.result.SMSParsedResult;
import com.google.zxing.searchbox.client.result.TextParsedResult;
import com.google.zxing.searchbox.client.result.URIParsedResult;

import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.params.HttpConnectionParams;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.net.UnknownHostException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.GZIPInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

/**
 * 提供一些常用工具方法.
 *
 * <br/>
 * <b>对外提供框能力，因此NoProGuard</b>
 */
public final class Utility implements NoProGuard {
    /** 网络类型 wifi */
    private static final String NET_TYPE_WIFI = "wifi";
    /** TAG. */
    private static final String TAG = "Utility";
    /** DEBUG. */
    private static final boolean DEBUG = SearchBox.GLOBAL_DEBUG & true;

    /** mode=2中的浏览框架参数 */
    public static final String PARAM_BROWSER_TYPE = "browser";
    /** mode=2中的主浏览框架参数值 */
    public static final String VALUE_BROWSER_IN_MAIN = "main";
    /** mode=2中的轻浏览框架参数值 */
    public static final String VALUE_BROWSER_IN_LIGHT = "light";
    /** mode=2中的appid参数 */
    public static final String PARAM_APPID = "appid";

    /**
     * File buffer stream size.
     */
    public static final int FILE_STREAM_BUFFER_SIZE = 8192;

    /** 1KB. */
    public static final int KB = 1024;
    /** 1MB. */
    public static final int MB = 1024 * 1024;
    /** 1GB. */
    public static final int GB = 1024 * 1024 * 1024;
    /** 不带alpha通道的颜色标准位数 */
    private static final int NO_ALPHA_STANDARD = 7;
    /** 带alpha通道的颜色标准位数 */
    private static final int WITH_ALPHA_STANDARD = 9;

    /** density */
    private static int mDensity = android.util.DisplayMetrics.DENSITY_HIGH;

    /** 真正的Density，而不是densityDpi */
    private static float mFloatDensity = (float) 1.5; // SUPPRESS CHECKSTYLE

    // 暂且将app分为三种类别：后装app、前装app、前装app的升级包。
    /** 后装app */
    private static final int USER_APP = 0;
    /** 前装app(OEM内置且具有系统权限) */
    private static final int SYSTEM_APP = 1;
    /** 前装app的升级包(OEM内置且具有系统权限的升级包) */
    private static final int SYSTEM_UPDATE_APP = 2;

    /** SD卡存储cache路径 */
    private static final String EXTERNAL_STORAGE_WIDGET_DIRECTORY = "/baidu/searchbox/widget";

    /** SD卡存储cache路径 */
    private static final String EXTERNAL_STORAGE_DIRECTORY = "/baidu/searchbox";

    /** 用于替换GZIP前两个字节的魔法数字，第一个字节 */
    public static final byte GZIP_HEAD_1 = 0x75;
    /** 用于替换GZIP前两个字节的魔法数字，第二个字节 */
    public static final byte GZIP_HEAD_2 = 0x7B;
    /** 方法调用者在stack中的位置 */
    private static final int CALLER_INDEX = 4;

    /** 客户端VersionCode */
    private static String sBoxVersionCode = null;

    /** 客户端VersionName */
    private static String sBoxVersionName = null;

    /** 支持的条码类型 */
    private static final int CONF_BARCODE = Barcode.B_EAN | Barcode.B_EAN8 | Barcode.B_CODE39 | Barcode.B_I25
            | Barcode.B_CODE128 | Barcode.B_UPCE;

    /** ResultViewHandler */
    private static final ResultViewHandlerImpl impl = new ResultViewHandlerImpl();

    /**
     * 默认包名
     */
    private static final String  DEFAULT_PACKAGE_NAME ="com.baidu.searchbox";

    /** weekly包名 */
    public static final String WEEKLY_PACKAGE_NAME = "com.baidu.searchbox.weekly";

    /** preview 包名*/
    public static final String PREVIEW_PACKAGE_NAME = "com.baidu.searchbox.preview";
    // public static final String WEEKLY_PACKAGE_NAME = "com.baidu.searchbox";

    /** command类型的action **/
    public static final String ACTION_TYPE_COMMAND = "type";
    /** command类型的data **/
    public static final String ACTION_DATA_COMMAND = "data";
    /** command类型的value **/
    public static final String ACTION_TYPE_VALUE = "1";

    /** 标准状态栏高度 */
    private static final int STANDARD_STATUSBAR_HEIGHT = 50;
    /** 系统显示 */
    private static final DisplayMetrics DISPLAY_METRICS = SearchBox.getAppContext().getResources().getDisplayMetrics();
    /** 屏幕密度 */
    private static final float SCREEN_DENSITY = DISPLAY_METRICS.density;

    /** 私有构造函数. */
    private Utility() {

    }

    /**
     * 获取app类型,目的是了解app是否具备系统权限.
     *
     * @param context 上下文
     * @param pkgName 包名
     * @return app类型: 0代表后装app; 1代表前装system app; 2代表前装app的升级包; .
     */
    @PluginAccessable(methodName = "getAppType", paramClasses = { Context.class, String.class })
    public static int getAppType(Context context, String pkgName) {
        PackageManager pm = SearchBox.getAppContext().getPackageManager();

        int type = USER_APP;

        try {
            ApplicationInfo appInfo = pm.getApplicationInfo(pkgName, 0);

            if ((appInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) == ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) {
                type = SYSTEM_UPDATE_APP;
            } else if ((appInfo.flags & ApplicationInfo.FLAG_SYSTEM) == ApplicationInfo.FLAG_SYSTEM) {
                type = SYSTEM_APP;
            } else {
                type = USER_APP;
            }

        } catch (NameNotFoundException e) {
            e.printStackTrace();
        }
        return type;
    }

    /**
     * 发送到服务端的参数数据要先进行加密处理
     *
     * @param param 发送的数据（一般都是JSON格式）
     * @return 加密过的数据
     */
    @PluginAccessable(methodName = "encryptePostContent", paramClasses = { String.class })
    public static String encryptePostContent(String param) {
        byte[] value = (param).getBytes();
        byte[] gzipvalue = GZIP.gZip(value);
        // 替换前两个字节的魔法数字为757B(十六进制)
        gzipvalue[0] = 0x75; // SUPPRESS CHECKSTYLE
        gzipvalue[1] = 0x7B; // SUPPRESS CHECKSTYLE

        return Base64.encodeToString(gzipvalue, Base64.DEFAULT);
    }

    /**
     * 调用一个对象的隐藏方法。
     *
     * @param obj 调用方法的对象.
     * @param methodName 方法名。
     * @param types 方法的参数类型。
     * @param args 方法的参数。
     * @return 如果调用成功，则返回true。
     */
    @PluginAccessable(methodName = "invokeHideMethod", paramClasses = { Object.class, String.class, Class[].class,
            Object[].class })
    public static boolean invokeHideMethod(Object obj, String methodName, Class<?>[] types, Object[] args) {
        boolean hasInvoked = false;
        try {
            Class<?> cls;
            if (obj instanceof Class<?>) { // 静态方法
                cls = (Class<?>) obj;
            } else { // 非静态方法
                cls = obj.getClass();
            }
            Method method = cls.getMethod(methodName, types);
            method.invoke(obj, args);
            hasInvoked = true;
            if (SearchBox.DEBUG) {
                Log.d(TAG, "Method \"" + methodName + "\" invoked success!");
            }
        } catch (Exception e) {
            if (SearchBox.DEBUG) {
                Log.d(TAG, "Method \"" + methodName + "\" invoked failed: " + e.getMessage());
            }
        }
        return hasInvoked;
    }

    /**
     * 调用一个对象的隐藏方法。
     *
     * @param obj 调用方法的对象.
     * @param methodName 方法名。
     * @param types 方法的参数类型。
     * @param args 方法的参数。
     * @return 隐藏方法调用的返回值。
     */
    @PluginAccessable(methodName = "invokeHideMethodForObject", paramClasses = { Object.class, String.class,
            Class[].class, Object[].class })
    public static Object invokeHideMethodForObject(Object obj, String methodName, Class<?>[] types, Object[] args) {
        Object o = null;
        try {
            Class<?> cls;
            if (obj instanceof Class<?>) { // 静态方法
                cls = (Class<?>) obj;
            } else { // 非静态方法
                cls = obj.getClass();
            }
            Method method = cls.getMethod(methodName, types);
            o = method.invoke(obj, args);
            if (SearchBox.DEBUG) {
                Log.d(TAG, "Method \"" + methodName + "\" invoked success!");
            }
        } catch (Exception e) {
            if (SearchBox.DEBUG) {
                Log.d(TAG, "Method \"" + methodName + "\" invoked failed: " + e.getMessage());
            }
        }
        return o;
    }

    /**
     * 调用一个对象的私有方法。
     *
     * @param obj 调用方法的对象.
     * @param methodName 方法名。
     * @param types 方法的参数类型。
     * @param args 方法的参数。
     * @return 如果调用成功，则返回true。
     */
    @PluginAccessable(methodName = "invokeDeclaredMethod", paramClasses = { Object.class, String.class, Class[].class,
            Object[].class })
    public static boolean invokeDeclaredMethod(Object obj, String methodName, Class<?>[] types, Object[] args) {
        boolean hasInvoked = false;
        try {
            Class<?> cls;
            if (obj instanceof Class<?>) { // 静态方法
                cls = (Class<?>) obj;
            } else { // 非静态方法
                cls = obj.getClass();
            }
            Method method = cls.getDeclaredMethod(methodName, types);
            method.setAccessible(true);
            method.invoke(obj, args);
            hasInvoked = true;
            if (SearchBox.DEBUG) {
                Log.d(TAG, "Method \"" + methodName + "\" invoked success!");
            }
        } catch (Exception e) {
            if (SearchBox.DEBUG) {
                Log.d(TAG, "Method \"" + methodName + "\" invoked failed: " + e.getMessage());
            }
        }
        return hasInvoked;
    }

    /**
     * 调用一个对象的私有方法。
     *
     * @param obj 调用方法的对象.
     * @param methodName 方法名。
     * @param types 方法的参数类型。
     * @param args 方法的参数。
     * @return 私有方法调用的返回值。
     */
    @PluginAccessable(methodName = "invokeDeclaredMethodForObject", paramClasses = { Object.class, String.class,
            Class[].class, Object[].class })
    public static Object invokeDeclaredMethodForObject(Object obj, String methodName, Class<?>[] types, Object[] args) {
        Object o = null;
        try {
            Class<?> cls;
            if (obj instanceof Class<?>) { // 静态方法
                cls = (Class<?>) obj;
            } else { // 非静态方法
                cls = obj.getClass();
            }
            Method method = cls.getDeclaredMethod(methodName, types);
            method.setAccessible(true);
            o = method.invoke(obj, args);
            if (SearchBox.DEBUG) {
                Log.d(TAG, "Method \"" + methodName + "\" invoked success!");
            }
        } catch (Exception e) {
            if (SearchBox.DEBUG) {
                Log.d(TAG, "Method \"" + methodName + "\" invoked failed: " + e.getMessage());
            }
        }
        return o;
    }

    /**
     * 判断是否是该改包名版本
     *
     * @return
     */
    public static boolean isModifyPkg() {
        return !TextUtils.equals(SearchBox.getPkgName(), DEFAULT_PACKAGE_NAME);
    }


    /**
     * 获取状态栏高度
     * @return int 状态栏高度
     */
    public static int getStatusBarHeight() {
        int result = 0;
        int resourceId = SearchBox.getAppContext().getResources()
                .getIdentifier("status_bar_height", "dimen", "android");
        if (resourceId > 0) {
            result = SearchBox.getAppContext().getResources().getDimensionPixelSize(resourceId);
        } else {
            result = (int) (STANDARD_STATUSBAR_HEIGHT / 2 * SCREEN_DENSITY);
        }
        return result;
    }


    /**
     * invoke object's method including private method
     *
     * @param owner : target object
     * @param methodName : name of the target method
     * @param parameterTypes : types of the target method's parameters
     * @param parameters : parameters of the target method
     * @return result of invoked method
     * @throws NoSuchMethodException NoSuchMethodException
     * @throws IllegalArgumentException IllegalArgumentException
     * @throws IllegalAccessException IllegalAccessException
     * @throws InvocationTargetException InvocationTargetException
     */
    @PluginAccessable(methodName = "invokePublicMethod", paramClasses = { Object.class, String.class, Class[].class,
            Object[].class })
    public static Object invokePublicMethod(Object owner, String methodName, Class<?>[] parameterTypes,
            Object[] parameters) throws NoSuchMethodException, IllegalArgumentException, IllegalAccessException,
            InvocationTargetException {
        if (null == owner) {
            return null;
        }
        // 获取所有public方法，包括父类的
        Method method = owner.getClass().getMethod(methodName, parameterTypes);
        Object result = method.invoke(owner, parameters);
        return result;
    }

    /**
     * 获取设备上某个volume对应的存储路径
     *
     * @param volume 存储介质
     * @return 存储路径
     */
    @PluginAccessable(methodName = "getVolumePath", paramClasses = { Object.class })
    public static String getVolumePath(Object volume) {
        String result = "";
        Object o = Utility.invokeHideMethodForObject(volume, "getPath", null, null);
        if (o != null) {
            result = (String) o;
        }

        return result;
    }

    /**
     * 获取设备上所有volume
     *
     * @param context context
     * @return Volume数组
     */
    @PluginAccessable(methodName = "getVolumeList", paramClasses = { Context.class })
    public static Object[] getVolumeList(Context context) {
        StorageManager manager =
                (StorageManager) SearchBox.getAppContext().getSystemService(Context.STORAGE_SERVICE);
        Object[] result = null;
        Object o = Utility.invokeHideMethodForObject(manager, "getVolumeList", null, null);
        if (o != null) {
            result = (Object[]) o;
        }

        return result;
    }

    /**
     * 获取设备上某个volume的状态
     *
     * @param context context
     * @param volumePath volumePath
     * @return result
     */
    @PluginAccessable(methodName = "getVolumeState", paramClasses = { Context.class, String.class })
    public static String getVolumeState(Context context, String volumePath) {
        StorageManager manager =
                (StorageManager) SearchBox.getAppContext().getSystemService(Context.STORAGE_SERVICE);
        String result = "";
        Object o =
                Utility.invokeHideMethodForObject(manager, "getVolumeState", new Class[] { String.class },
                        new Object[] { volumePath });
        if (o != null) {
            result = (String) o;
        }

        return result;
    }

    /**
     * Hides the input method.
     *
     * @param context context
     * @param view The currently focused view
     * @return success or not.
     */
    @PluginAccessable(methodName = "hideInputMethod", paramClasses = { Context.class, View.class })
    public static boolean hideInputMethod(Context context, View view) {
        if (view == null) {
            return false;
        }

        InputMethodManager imm =
                (InputMethodManager) SearchBox.getAppContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        if (imm != null) {
            return imm.hideSoftInputFromWindow(view.getWindowToken(), 0);
        }

        return false;
    }

    /**
     * Show the input method.
     *
     * @param context context
     * @param view The currently focused view, which would like to receive soft keyboard input
     * @return success or not.
     */
    @PluginAccessable(methodName = "showInputMethod", paramClasses = { Context.class, View.class })
    public static boolean showInputMethod(Context context, View view) {
        if (view == null) {
            return false;
        }

        InputMethodManager imm =
                (InputMethodManager) SearchBox.getAppContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        if (imm != null) {
            return imm.showSoftInput(view, 0);
        }

        return false;
    }

    /**
     * Show the input method.
     *
     * @param context context
     * @param view The currently focused view, which would like to receive soft keyboard input
     * @param receiver If non-null, this will be called by the IME when it has processed your request to tell you what
     *            it has done. The result code you receive may be either
     *            {@link InputMethodManager#RESULT_UNCHANGED_SHOWN}, {@link InputMethodManager#RESULT_UNCHANGED_HIDDEN},
     *            {@link InputMethodManager#RESULT_SHOWN}, or {@link InputMethodManager#RESULT_HIDDEN}.
     * @return success or not.
     */
    @PluginAccessable(methodName = "showInputMethod",
            paramClasses = { Context.class, View.class, ResultReceiver.class })
    public static boolean showInputMethod(Context context, View view, ResultReceiver receiver) {
        if (view == null) {
            return false;
        }

        InputMethodManager imm =
                (InputMethodManager) SearchBox.getAppContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        if (imm != null) {
            return imm.showSoftInput(view, 0, receiver);
        }

        return false;
    }

    /**
     * 获取指定resource id的Uri.
     *
     * @param packageContext 指定的包。
     * @param res 资源ID
     * @return 资源的Uri
     */
    @PluginAccessable(methodName = "getResourceUri", paramClasses = { Context.class, int.class })
    public static Uri getResourceUri(Context packageContext, int res) {
        try {
            Resources resources = packageContext.getResources();
            return getResourceUri(resources, packageContext.getPackageName(), res);
        } catch (Resources.NotFoundException e) {
            if (DEBUG) {
                Log.e(TAG, "Resource not found: " + res + " in " + packageContext.getPackageName());
            }
            return null;
        }
    }

    /**
     * 根据ApplicationInfo 获取Resource Uri.
     *
     * @param context context
     * @param appInfo ApplicationInfo
     * @param res 资源ID
     * @return 资源的Uri
     */
    @PluginAccessable(methodName = "getResourceUri",
            paramClasses = { Context.class, ApplicationInfo.class, int.class })
    public static Uri getResourceUri(Context context, ApplicationInfo appInfo, int res) {
        try {
            Resources resources = context.getPackageManager().getResourcesForApplication(appInfo);
            return getResourceUri(resources, appInfo.packageName, res);
        } catch (PackageManager.NameNotFoundException e) {
            if (DEBUG) {
                Log.e(TAG, "Resources not found for " + appInfo.packageName);
            }
            return null;
        } catch (Resources.NotFoundException e) {
            if (DEBUG) {
                Log.e(TAG, "Resource not found: " + res + " in " + appInfo.packageName);
            }
            return null;
        }
    }

    /**
     * 构建Resource Uri。
     *
     * @param resources 应用关联的资源。
     * @param appPkg 应用包名。
     * @param res 资源包名
     * @return 资源的Uri
     * @throws Resources.NotFoundException 资源没找到的异常。
     */
    private static Uri getResourceUri(Resources resources, String appPkg, int res) throws Resources.NotFoundException {
        String resPkg = resources.getResourcePackageName(res);
        String type = resources.getResourceTypeName(res);
        String name = resources.getResourceEntryName(res);
        return makeResourceUri(appPkg, resPkg, type, name);
    }

    /**
     * 构建Resource Uri.
     *
     * @param appPkg 应用包名。
     * @param resPkg 资源包名
     * @param type 资源类型
     * @param name 资源名
     * @return 资源的Uri
     */
    private static Uri makeResourceUri(String appPkg, String resPkg, String type, String name) {
        // TODO 了解type种类。
        Uri.Builder uriBuilder = new Uri.Builder();
        uriBuilder.scheme(ContentResolver.SCHEME_ANDROID_RESOURCE);
        uriBuilder.encodedAuthority(appPkg);
        uriBuilder.appendEncodedPath(type);
        if (!appPkg.equals(resPkg)) {
            uriBuilder.appendEncodedPath(resPkg + ":" + name);
        } else {
            uriBuilder.appendEncodedPath(name);
        }
        return uriBuilder.build();
    }

    // <add by fujiaxing 20111206 BEGIN
    /**
     * 创建一个 http client。
     *
     * @param context Context.
     * @return ProxyHttpClient
     */
    public static ProxyHttpClient createHttpClient(Context context) {
        ProxyHttpClient httpclient = new ProxyHttpClient(context);
        // httpclient.getParams().setParameter("Accept-Encoding", "gzip");

        final int httpTimeout = 30000;
        final int socketTimeout = 50000;
        HttpConnectionParams.setConnectionTimeout(httpclient.getParams(), httpTimeout);
        HttpConnectionParams.setSoTimeout(httpclient.getParams(), socketTimeout);
        return httpclient;
    }

    /**
     * 对url中的参数进行编码.
     *
     * @param url String
     * @return 编码后的url
     */
    @PluginAccessable(methodName = "encodeUrl", paramClasses = { String.class })
    public static String encodeUrl(String url) {
        int index = url.indexOf("?");
        if (index != -1 && index + 1 <= url.length()) { // 对url 问号后的部分编码
            String tmpUrl = url.substring(0, index + 1);
            String param = url.substring(index + 1);
            param = urlEncode(param);
            url = tmpUrl + param;
        }
        return url;
    }

    /**
     * 对url参数的value进行utf-8编码.
     *
     * @param str Url.
     * @return Url.
     */
    private static String urlEncode(String str) {
        if (TextUtils.isEmpty(str)) {
            return "";
        }

        StringBuffer sb = new StringBuffer(str.length() * 2);
        String[] pairs = str.split("&");
        int size = pairs.length;
        String pair;
        for (int i = 0; i < size; i++) {
            pair = pairs[i];
            int idx = pair.indexOf("=");
            if (idx > 0 && pair.indexOf("%") < 0) {
                String value = pair.substring(idx + 1);
                sb.append(pair.substring(0, idx));
                sb.append('=');
                sb.append(Uri.encode(value));
            } else {
                sb.append(pair);
            }
            if (i < size - 1) {
                sb.append('&');
            }
        }

        return sb.toString().trim();
    }

    // add by fujiaxing 20111206 END>

    // /**
    // * 生成设备id。
    // * 由于有些设备没有电话功能，所以不能依赖于 imei。
    // * Secure.ANDROID_ID 在 froyo以前版本也不可靠
    // * 我们还需要考虑模拟器，模拟器目前看来有个电话号码可用。
    // *
    // * 所以结合起来搞了一个md5.
    // *
    // * deviceid 问题请参考
    // *
    // http://android-developers.blogspot.com/2011/03/identifying-app-installations.html
    // *
    // * @param context Context
    // * @return device id.
    // */
    // public static String getDeviceID(Context context) {
    // String tmDevice = "";
    // String androidId = "";
    // String deviceMobileNo = "";
    //
    // final TelephonyManager tm = (TelephonyManager)
    // context.getSystemService(Context.TELEPHONY_SERVICE);
    // if (tm != null) {
    // tmDevice = "" + tm.getDeviceId();
    // // 针对 模拟器才取手机号。因为模拟器andorid2.2 以下版本 imei/ANDROID_ID 都不可用。
    // if ("000000000000000".equals(tmDevice)) {
    // deviceMobileNo = "" + tm.getLine1Number();
    // }
    // }
    //
    // androidId = "" + Secure.getString(context.getContentResolver(),
    // Secure.ANDROID_ID);
    //
    // String deviceUUID = toMd5((tmDevice + androidId +
    // deviceMobileNo).getBytes(), false);
    //
    // return deviceUUID;
    // }

    /**
     * 把二进制byte数组生成 md5 32位 十六进制字符串，单个字节小于0xf，高位补0。
     *
     * @param bytes 输入
     * @param upperCase true：大写， false 小写字符串
     * @return 把二进制byte数组生成 md5 32位 十六进制字符串，单个字节小于0xf，高位补0。
     */
    @PluginAccessable(methodName = "toMd5", paramClasses = { byte[].class, boolean.class })
    public static String toMd5(byte[] bytes, boolean upperCase) {
        try {
            MessageDigest algorithm = MessageDigest.getInstance("MD5");
            algorithm.reset();
            algorithm.update(bytes);
            return toHexString(algorithm.digest(), "", upperCase);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 计算文件Md5 32位 十六进制字符串，单个字节小于0xf，高位补0
     *
     * @param file 文件
     * @param upperCase true：大写， false 小写字符串
     * @return Md5 32位 十六进制字符串，单个字节小于0xf，高位补0
     */
    @PluginAccessable(methodName = "toMd5", paramClasses = { File.class, boolean.class })
    public static String toMd5(File file, boolean upperCase) {
        InputStream is = null;
        try {
            MessageDigest algorithm = MessageDigest.getInstance("MD5");
            algorithm.reset();
            is = new FileInputStream(file);
            byte[] buffer = new byte[FILE_STREAM_BUFFER_SIZE];
            int read = 0;
            while ((read = is.read(buffer)) > 0) {
                algorithm.update(buffer, 0, read);
            }
            return toHexString(algorithm.digest(), "", upperCase);
        } catch (NoSuchAlgorithmException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        } catch (FileNotFoundException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        } catch (IOException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        } finally {
            if (is != null) {
                try {
                    is.close();
                } catch (IOException e) {
                    if (DEBUG) {
                        e.printStackTrace();
                    }
                }
            }
        }

        return null;
    }

    /**
     * 把二进制byte数组生成十六进制字符串，单个字节小于0xf，高位补0。
     *
     * @param bytes 输入
     * @param separator 分割线
     * @param upperCase true：大写， false 小写字符串
     * @return 把二进制byte数组生成十六进制字符串，单个字节小于0xf，高位补0。
     */
    private static String toHexString(byte[] bytes, String separator, boolean upperCase) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            String str = Integer.toHexString(0xFF & b); // SUPPRESS CHECKSTYLE
            if (upperCase) {
                str = str.toUpperCase();
            }
            if (str.length() == 1) {
                hexString.append("0");
            }
            hexString.append(str).append(separator);
        }
        return hexString.toString();
    }

    /**
     * 获取软件用户唯一标示码。 2 + 16 + 4 + 16 位长。
     *
     * 前两位为 产品标识码。百度搜索位 10.
     *
     * 中间十六位和后十六位 位 deviceid 的 32 位 分为两部分。
     *
     * 中间四位为采用一个规则从 32位deviceid中取出的4位。
     *
     *
     * @param context Context
     * @return 软件uuid。
     */
    @PluginAccessable(methodName = "getSoftwareUUID", paramClasses = { Context.class })
    public static String getSoftwareUUID(Context context) {
        final String productId = "10"; // 百度搜索产品id 为 10；
        String deviceId = DeviceId.getDeviceID(SearchBox.getAppContext());

        // System.out.println(deviceId);

        StringBuffer sb = new StringBuffer();
        sb.append(productId);
        sb.append(deviceId.substring(0, deviceId.length() / 2));

        // 取第2位的十六进制转化为十进制作为 起始位置。
        int start = Integer.parseInt(Character.toString(deviceId.charAt(2)), 16); // SUPPRESS CHECKSTYLE

        for (int i = 0; i < 4; i++) { // SUPPRESS CHECKSTYLE
            int index = (start + i * 8 + 1) % deviceId.length(); // SUPPRESS CHECKSTYLE

            // System.out.println(index);

            sb.append(deviceId.charAt(index));
        }

        sb.append(deviceId.substring(deviceId.length() / 2));

        String result = sb.toString().toUpperCase();

        // System.out.println("result : " + result + " length = " +
        // result.length());

        return result;
    }

    /**
     * 安全启动应用程序，截获Exception。
     *
     * @param activity Activity
     * @param intent Intent
     */
    @PluginAccessable(methodName = "startActivitySafely", paramClasses = { Activity.class, Intent.class })
    public static void startActivitySafely(Activity activity, Intent intent) {
        startActivitySafely(activity, intent, true);
    }

    /**
     * 安全启动应用程序，截获Exception。
     *
     * @param activity activity
     * @param intent Intent
     * @param newTask 是否添加Intent.FLAG_ACTIVITY_NEW_TASK
     * @return 是否调起成功
     */
    @PluginAccessable(methodName = "startActivitySafely", 
            paramClasses = { Context.class, Intent.class, boolean.class })
    public static boolean startActivitySafely(
            Context activity, Intent intent, boolean newTask) {

        return startActivitySafely(activity, intent, newTask, true);
    }
    
    /**
     * 安全启动应用程序，截获Exception
     * 
     * @param activity {@link Context}
     * @param intent {@link Intent}
     * @param newTask 是否添加Intent中的FLAG_ACTIVITY_NEW_TASK标志
     * @param withToast 是否弹出Toast
     * @return 是否调起成功
     */
    public static boolean startActivitySafely(
            Context activity, Intent intent, boolean newTask, boolean withToast) {
        
        boolean ret = false;
        if (newTask || !(activity instanceof Activity)) {
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        }
        try {
            activity.startActivity(intent);
            ret = true;
        } catch (ActivityNotFoundException e) {
            if (withToast) {
                Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
            }
        } catch (SecurityException e) {
            if (withToast) {
                Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
            }
            if (SearchBox.DEBUG) {
                Log.e(TAG, "Launcher does not have the permission to launch " + intent
                        + ". Make sure to create a MAIN intent-filter for the corresponding activity "
                        + "or use the exported attribute for this activity.", e);
            }
        }
        return ret;
    }

    /**
     * 安全启动应用程序，截获Exception。 必须在主线程被调用
     *
     * @param context context
     * @param intent Intent
     * @return 是否成功启动Activity。
     */
    @PluginAccessable(methodName = "startActivitySafely", paramClasses = { Context.class, Intent.class })
    public static boolean startActivitySafely(Context context, Intent intent) {
        return startActivitySafely(context, intent, false);
    }

    /**
     * 安全启动应用程序，截获Exception，并返回是否成功启动。
     *
     * @param context Context.
     * @param packageName 包名.
     * @param activityName Activity全名（加上包名前缀）.
     * @return 是否成功启动Activity。
     */
    @PluginAccessable(methodName = "startActivitySafely", paramClasses = { Context.class, String.class, String.class })
    public static boolean startActivitySafely(Context context, String packageName, String activityName) {
        
        return startActivitySafely(context, packageName, activityName, true);
    }
    
    /**
     * 安全启动应用程序，截获Exception，并返回是否成功启动。
     *
     * @param context Context.
     * @param packageName 包名.
     * @param activityName Activity全名（加上包名前缀）.
     * @param withToast 是否弹出Toast
     * @return 是否成功启动Activity。
     */
    public static boolean startActivitySafely(
            Context context, String packageName, String activityName, boolean withToast) {
        
        boolean result = false;
        if (!TextUtils.isEmpty(packageName) && !TextUtils.isEmpty(activityName)) {
            ComponentName component = new ComponentName(packageName, activityName);
            result = startActivitySafely(context, component, withToast);
        }
        return result; 
    }

    /**
     * 安全启动应用程序，截获Exception，并返回是否成功启动。
     *
     * @param context Context.
     * @param component 组件名，由包名和Activity全名（加上包名前缀）共同生成.
     * @return 是否成功启动Activity。
     */
    @PluginAccessable(methodName = "startActivitySafely", paramClasses = { Context.class, ComponentName.class })
    public static boolean startActivitySafely(Context context, ComponentName component) {
        
        return startActivitySafely(context, component, true);
    }
    
    /**
     * 安全启动应用程序，截获Exception，并返回是否成功启动。
     *
     * @param context Context.
     * @param component 组件名，由包名和Activity全名（加上包名前缀）共同生成.
     * @param withToast 是否弹出Toast
     * @return 是否成功启动Activity。
     */
    public static boolean startActivitySafely(Context context, ComponentName component, boolean withToast) {
        
        boolean ret = false;
        if (component != null) {
            Intent intent = new Intent();
            intent.setComponent(component);
            ret = startActivitySafely(context, intent, true, withToast);
        }
        return ret;
    }

    /**
     * 启动不确定的Activity。该函数主要用来启动诸如闹钟日历这种无标准intent的Activity。 如果通过默认的包名和Activity名启动失败，则扫描应用程序，通过包名后缀和Activity后缀来匹配，
     * 直到启动成功或者扫描结束为止。 注意，为了安全起见，目前只扫描内置的应用程序 。
     *
     * @param context Context.
     * @param defaultPackageNames 默认的包名集合。
     * @param defaultActivityNames 对应的默认Activity名集合。
     * @param packagePostfix 包名后缀。
     * @param activityPostfix Activity后缀（请加上"."）。
     * @param packageSaveKey 用来保存成功启动的组件包名。
     * @param activitySaveKey 用来保存成功启动的组件Activity名。
     * @return 如果能成功启动某个Activity，则返回它的组件名；否则返回null.
     */
    @PluginAccessable(methodName = "startUncertainActivitySafely", paramClasses = { Context.class, String[].class,
            String[].class, String.class, String.class, String.class, String.class })
    public static ComponentName startUncertainActivitySafely(Context context, String[] defaultPackageNames,
            String[] defaultActivityNames, String packagePostfix, String activityPostfix, String packageSaveKey,
            String activitySaveKey) {
        ComponentName result = null;

        if (defaultPackageNames == null || defaultActivityNames == null) {
            return result;
        }

        int length =
                defaultPackageNames.length < defaultActivityNames.length ? defaultPackageNames.length
                        : defaultActivityNames.length;

        ComponentName[] components = new ComponentName[length];
        for (int i = 0; i < length; i++) {
            components[i] = new ComponentName(defaultPackageNames[i], defaultActivityNames[i]);
        }

        result =
                startUncertainActivitySafely(context, components, packagePostfix, activityPostfix, packageSaveKey,
                        activitySaveKey);

        return result;
    }

    /**
     * 启动不确定的Activity。该函数主要用来启动诸如闹钟日历这种无标准intent的Activity。 如果通过默认的包名和Activity名启动失败，则扫描应用程序，通过包名后缀和Activity后缀来匹配，
     * 直到启动成功或者扫描结束为止。 注意，为了安全起见，目前只扫描内置的应用程序 。
     *
     * @param context Context.
     * @param defaultComponents 默认的组件名集合。
     * @param packagePostfix 包名后缀。
     * @param activityPostfix Activity后缀（请加上"."）。
     * @param packageSaveKey 用来保存成功启动的组件包名。
     * @param activitySaveKey 用来保存成功启动的组件Activity名。
     * @return 如果能成功启动某个Activity，则返回它的组件名；否则返回null.
     */
    @PluginAccessable(methodName = "startUncertainActivitySafely", paramClasses = { Context.class,
            ComponentName[].class, String.class, String.class, String.class, String.class })
    public static ComponentName startUncertainActivitySafely(Context context, ComponentName[] defaultComponents,
            String packagePostfix, String activityPostfix, String packageSaveKey, String activitySaveKey) {
        ComponentName result = null;

        String savePackageName = null;
        String saveActivityName = null;
        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
        savePackageName = preferences.getString(packageSaveKey, null);
        saveActivityName = preferences.getString(activitySaveKey, null);

        if (savePackageName != null && saveActivityName != null
                && startActivitySafely(context, savePackageName, saveActivityName, false)) {
            result = new ComponentName(savePackageName, saveActivityName);
            return result;
        }

        if (defaultComponents != null) {
            for (ComponentName componentName : defaultComponents) {
                if (DEBUG) {
                    if (componentName != null) {
                        Log.d(TAG, "startUncertainActivitySafely: className=" + componentName.getClassName());
                        Log.d(TAG, "startUncertainActivitySafely: packageName=" + componentName.getPackageName());
                    }
                }
                if (startActivitySafely(context, componentName, false)) {
                    result = componentName;
                    break;
                }
            }
        }

        if (result == null) {
            if (DEBUG) {
                Log.d(TAG, "startUncertainActivitySafely: result == null");
            }
            List<PackageInfo> packageInfos = context.getPackageManager().getInstalledPackages(0);
            for (PackageInfo pi : packageInfos) { // 是内置应用，且包名以"clock"结束
                if (((pi.applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) == ApplicationInfo.FLAG_UPDATED_SYSTEM_APP || (pi.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == ApplicationInfo.FLAG_SYSTEM)
                        && pi.packageName.endsWith(packagePostfix)) {

                    ComponentName componentName = new ComponentName(pi.packageName, pi.packageName + activityPostfix);
                    if (DEBUG) {
                        Log.d(TAG, "startUncertainActivitySafely: className=" + componentName.getClassName());
                        Log.d(TAG, "startUncertainActivitySafely: packageName=" + componentName.getPackageName());
                    }
                    // 有Activity名以"AlarmClock"结束，并能成功启动
                    if (startActivitySafely(context, componentName, false)) {
                        result = componentName;
                        break;
                    }
                }
            }
        }

        if (result != null) {
            Editor editor = preferences.edit();
            editor.putString(packageSaveKey, result.getPackageName());
            editor.putString(activitySaveKey, result.getClassName());
            editor.commit();
        } else {
            Toast.makeText(context, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
        }
        
        return result;
    }

    // <add by fujiaxing 20120110 BEGIN
    /**
     * 从输入流中获得字符串.
     *
     * @param inputStream {@link InputStream}
     * @return 字符串
     */
    @PluginAccessable(methodName = "getStringFromInput", paramClasses = { InputStream.class })
    public static String getStringFromInput(InputStream inputStream) {
        try {
            byte[] buf = getByteFromInputStream(inputStream);
            if (buf != null) {
                String str = new String(buf);
                // consume an optional byte order mark (BOM) if it exists
                // 此处对UTF8 BOM头进行去除处理，以免当String为JSON串的时候，
                // 在2.x平台用来构造JSONObject时会抛JSONException。
                if (str != null && str.startsWith("\ufeff")) {
                    str = str.substring(1);
                }
                return str;
            }
        } catch (Exception e) {
            if(DEBUG) {
                Log.e(TAG, " getStringFromInput exception: ", e);
            }
        } finally {
            Utility.closeSafely(inputStream);
        }
        return null;
    }

    // add by fujiaxing 20120110 END>
    /**
     * 从输入流中读出byte数组
     *
     * @param inputStream 输入流
     * @return byte[]
     */
    @PluginAccessable(methodName = "getByteFromInputStream", paramClasses = { InputStream.class })
    public static byte[] getByteFromInputStream(InputStream inputStream) {
        if (inputStream == null) {
            return null;
        }

        ByteArrayOutputStream bos = new ByteArrayOutputStream();

        byte[] buffer = new byte[1024]; // SUPPRESS CHECKSTYLE
        int len;
        do {
            len = 0;
            try {
                len = inputStream.read(buffer, 0, buffer.length);
            } catch (IOException e) {
                if (DEBUG) {
                    e.printStackTrace();
                }
            }
            if (len != -1) {
                // stringBuffer.append(new String(buffer, 0, len));
                bos.write(buffer, 0, len);
            } else {
                break;
            }
        } while (true);

        buffer = bos.toByteArray();
        try {
            bos.close();
        } catch (IOException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        }

        return buffer;
    }

    // add by fujiaxing 20120110 END>

    /** 用来存储widget信息的文件名。 */
    public static final String WIDGET_INFO_FILE = "widgetInfo";

    /**
     * 通过AppWidgetId与指定的key前缀来保存值。该函数主要用来保存每个widget实例的私有值。 支持的值类型有boolean、Float、Integer、Long以及String。
     * 注意，如果value为null，则将会以String形式保存。 如果value为非支持的类型，则抛出UnsupportedOperationException。
     *
     * @param context Context.
     * @param appWidgetId 每个widget实例对应的id.
     * @param keyPrefix key前缀，与appWidgetId联合生成key值.
     * @param value 需要保存的值。
     */
    public static void saveValueWithWidgetId(Context context, int appWidgetId, String keyPrefix, Serializable value) {
        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
        Editor editor = preferences.edit();
        String key = keyPrefix + appWidgetId;
        if (value == null) {
            editor.putString(key, null);
        } else if (value instanceof Boolean) {
            editor.putBoolean(key, (Boolean) value);
        } else if (value instanceof Float) {
            editor.putFloat(key, (Float) value);
        } else if (value instanceof Integer) {
            editor.putInt(key, (Integer) value);
        } else if (value instanceof Long) {
            editor.putLong(key, (Long) value);
        } else if (value instanceof String) {
            editor.putString(key, (String) value);
        } else {
            throw new UnsupportedOperationException();
        }

        editor.commit();

        // <added by qumiao 2012.3.26 BEGIN
        // 如果用户强制清除数据，SharedPreferences将会被擦除，所以再保留一份在sdcard中
        // modify by dongqi 2012.12.13 begin
        Intent intent = new Intent(CommonIntentService.ACTION_SAVE_WIDGETINFO_EXTERNAL);
        intent.setClassName(context.getPackageName(), CommonIntentService.class.getName());
        Bundle bundle = new Bundle();
        bundle.putSerializable(CommonIntentService.WIDGETINFO_EXTERNAL, value);
        bundle.putString(CommonIntentService.WIDGETINFO_KEY, key);
        intent.putExtras(bundle);
        context.startService(intent);
        // modify by dongqi 2012.12.13 end
        // added by qumiao 2012.3.26 END>
    }

    /**
     * 通过AppWidgetId与指定的key前缀来获取值。该函数主要用来获取每个widget实例的私有保存值。 支持的值类型有boolean、Float、Integer、Long以及String。
     * 注意，如果defaultValue为null，则将会以String形式获取值。 如果defaultValue为非支持的类型，则抛出UnsupportedOperationException。
     *
     * @param context Context.
     * @param appWidgetId 每个widget实例对应的id.
     * @param keyPrefix key前缀，与appWidgetId联合生成key值.
     * @param defaultValue 默认值.
     * @return 如果存在与key配对的值，则返回该值；否则返回defaultValue。
     */
    public static Object getValueWithWidgetId(Context context, int appWidgetId, String keyPrefix,
            Serializable defaultValue) {
        Object value = null;
        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
        String key = keyPrefix + appWidgetId;
        if (defaultValue == null) {
            value = preferences.getString(key, null);
        } else if (defaultValue instanceof Boolean) {
            value = preferences.getBoolean(key, (Boolean) defaultValue);
        } else if (defaultValue instanceof Float) {
            value = preferences.getFloat(key, (Float) defaultValue);
        } else if (defaultValue instanceof Integer) {
            value = preferences.getInt(key, (Integer) defaultValue);
        } else if (defaultValue instanceof Long) {
            value = preferences.getLong(key, (Long) defaultValue);
        } else if (defaultValue instanceof String) {
            value = preferences.getString(key, (String) defaultValue);
        } else {
            throw new UnsupportedOperationException();
        }

        // <added by qumiao 2012.3.26 BEGIN
        // 如果用户强制清除数据，SharedPreferences将会被擦除，所以再从sdcard中读取信息
        if (value == defaultValue) {
            String state = Environment.getExternalStorageState();

            if (Environment.MEDIA_MOUNTED.equals(state) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {

                File file = getExternalFilesDir(context, WIDGET_INFO_FILE);
                // modify by qumiao 可能不存在外部存储
                if (file == null) {
                    return value;
                }
                // end modify

                if (file.canRead()) {
                    FileInputStream in = null;
                    try {
                        in = new FileInputStream(file);
                        ObjectInputStream objectIn = new ObjectInputStream(in);
                        HashMap<String, Serializable> map = (HashMap<String, Serializable>) objectIn.readObject();
                        value = map.get(key);
                        in.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                        closeSafely(in);
                    }
                }
            }
        }

        if (value == null) {
            value = defaultValue;
        }
        // added by qumiao 2012.3.26 END>

        return value;
    }

    /**
     * 获取widget的category，用于判断widget类型，来区分统计行为
     *
     * @param context context
     * @param intent intent
     * @return category
     */
    public static String getCategoryOfWidget(Context context, Intent intent) {
        if (context == null || intent == null) {
            return null;
        }
        int appWidgetId =
                intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, AppWidgetManager.INVALID_APPWIDGET_ID);

        Set<String> categories = intent.getCategories();
        if (categories == null || categories.size() <= 0) {
            return null;
        }

        String category = categories.iterator().next();
        if (TextUtils.isEmpty(category) || appWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
            return null;
        }

        String keyPrefix = null;
        if (category.equals(ClockWidgetProvider.CATEGORY_CLOCK)) {
            keyPrefix = ClockWidgetProvider.PREF_KEY_CLOCK_CATEGORY;
        }

        if (!TextUtils.isEmpty(keyPrefix)) {
            return (String) Utility.getValueWithWidgetId(context, appWidgetId, keyPrefix, null);
        }

        return category;
    }

    /**
     * 获取外置存储目录中的文件。
     *
     * @param context Context.
     * @param fileName 文件名.
     * @return 文件.
     */
    @PluginAccessable(methodName = "getExternalFilesDir", paramClasses = { Context.class, String.class })
    public static File getExternalFilesDir(Context context, String fileName) {
        File file = null;

        // if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.ECLAIR_MR1) {
        // file = ExternalFilesDir7.getExternalFilesDir(context, fileName);
        // } else {
        // // modify by qumiao 可能不存在外部存储
        // File dir = context.getExternalFilesDir(null);
        // if (dir != null) {
        // String path = dir.getAbsolutePath();
        // file = new File(path, fileName);
        // }
        // // end modify
        // }
        // modify by liliang04
        // android defined file directory will be cleaned for "clear user data"
        // operation,
        // use a safer place instead
        File dir = new File(Environment.getExternalStorageDirectory(), EXTERNAL_STORAGE_WIDGET_DIRECTORY);

        if (ensureDirectoryExist(dir)) {
            file = new File(dir, fileName);
        }

        return file;
    }

    /**
     * 获得百度搜索在SD卡上的默认存储目录下的一个文件
     *
     * @param fileName 文件名
     * @return 在SD卡默认存储目录下的File对象。若不为null,则可以使用，默认存储目录保证存在；若为null，则默认存储目录创建失败。
     */
    @PluginAccessable(methodName = "getPublicExternalDiretory", paramClasses = { String.class })
    public static File getPublicExternalDiretory(String fileName) {
        File dir = new File(Environment.getExternalStorageDirectory(), EXTERNAL_STORAGE_DIRECTORY);
        File file = null;
        if (ensureDirectoryExist(dir)) {
            file = new File(dir, fileName);
        }

        return file;
    }

    /**
     * 获得百度搜索在SD卡上的默认存储目录下的一个文件路径
     *
     * @param fileName 文件名
     * @return 得到框公共目录+filename组成的文件路径
     */
    @PluginAccessable(methodName = "getPublicExternalPath", paramClasses = { String.class })
    public static String getPublicExternalPath(String fileName) {
        if (fileName == null) {
            fileName = "";
        }
        return Environment.getExternalStorageDirectory() + File.separator + EXTERNAL_STORAGE_DIRECTORY + File.separator
                + fileName;
    }

    /**
     * 确定SD卡缓存路径在使用前已经存在.
     *
     * @param dir 目录
     * @return 是否建立成功
     */
    @PluginAccessable(methodName = "ensureDirectoryExist", paramClasses = { File.class })
    public static boolean ensureDirectoryExist(final File dir) {
        if (dir == null) {
            return false;
        }
        if (!dir.exists()) {
            try {
                dir.mkdirs();
            } catch (SecurityException e) {
                return false;
            }
        }
        return true;
    }

    /**
     * SDK2.1(API 7)获取外置存储目录中的文件。
     *
     * @author qumiao
     *
     */
    private static class ExternalFilesDir7 {
        /**
         * 获取外置存储目录中的文件。
         *
         * @param context Context.
         * @param fileName 文件名.
         * @return File
         */
        static File getExternalFilesDir(Context context, String fileName) {
            String root = Environment.getExternalStorageDirectory().getAbsolutePath();
            String path = "/Android/data/" + context.getPackageName() + "/files/";
            return new File(root + path, fileName);
        }
    }

    // <add by fujiaxing 20120301 BEGIN
    /**
     * Convert a IPv4 address from an integer to an InetAddress.
     *
     * @param hostAddress an int corresponding to the IPv4 address in network byte order
     * @return {@link InetAddress}
     */
    @PluginAccessable(methodName = "intToInetAddress", paramClasses = { int.class })
    public static InetAddress intToInetAddress(int hostAddress) {
        byte[] addressBytes = { (byte) (0xff & hostAddress), // SUPPRESS CHECKSTYLE
                (byte) (0xff & (hostAddress >> 8)), // SUPPRESS CHECKSTYLE
                (byte) (0xff & (hostAddress >> 16)), // SUPPRESS CHECKSTYLE
                (byte) (0xff & (hostAddress >> 24)) }; // SUPPRESS CHECKSTYLE
        try {
            return InetAddress.getByAddress(addressBytes);
        } catch (UnknownHostException e) {
            throw new AssertionError();
        }
    }

    // add by fujiaxing 20120301 END>
    /**
     * 安全关闭.
     *
     * @param closeable Closeable.
     */
    @PluginAccessable(methodName = "closeSafely", paramClasses = { Closeable.class })
    public static void closeSafely(Closeable closeable) {
        try {
            if (closeable != null) {
                closeable.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 安全关闭.
     *
     * @param cursor Cursor.
     */
    @PluginAccessable(methodName = "closeSafely", paramClasses = { Cursor.class })
    public static void closeSafely(Cursor cursor) {
        try {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // <add by fujiaxing 20120417 BEGIN
    /**
     * 如果url没有scheme，则增加http
     *
     * @param url url
     * @return url
     */
    @PluginAccessable(methodName = "addSchemeIfNeed", paramClasses = { String.class })
    public static String addSchemeIfNeed(String url) {
        if (TextUtils.isEmpty(url)) {
            return null;
        }
        // 为了效率考虑，没有用webaddress进行正则处理，指示简单判断http和https
        if (url.startsWith("http://") || url.startsWith("https://") || url.startsWith("rtsp://")) {
            return url;
        } else {
            return "http://" + url;
        }
    }

    /**
     * 生成文件大小的字符串.
     *
     * @param size 文件大小
     * @return 表示经过格式的字符串
     */
    @PluginAccessable(methodName = "generateFileSizeText", paramClasses = { long.class })
    public static String generateFileSizeText(long size) {
        String unit;
        Float outNumber;
        if (size < KB) {
            return size + "B";
        } else if (size < MB) {
            unit = "KB";
            outNumber = (float) size / KB;
        } else if (size < GB) {
            unit = "MB";
            outNumber = (float) size / MB;
        } else {
            unit = "GB";
            outNumber = (float) size / GB;
        }
        /*
         * 文件大小显示格式化. 大于1KB的文件大小数字显示形如1011.11,小于1KB的文件显示具体大小
         */
        DecimalFormat formatter = new DecimalFormat("####.##");
        return formatter.format(outNumber) + unit;
    }

    // add by fujiaxing 20120417 END>
    /**
     * 判断一个字符串是否为合法url
     *
     * @param query String
     * @return true: 是合法url
     */
    @PluginAccessable(methodName = "isUrl", paramClasses = { String.class })
    public static boolean isUrl(String query) {
        Matcher matcher = Patterns.WEB_URL.matcher(query);
        if (matcher.matches()) {
            return true;
        } else {
            return Patterns.COARSE_WEB_URL.matcher(query).matches();
        }
    }

    /**
     * 判断是否需要黄反重定向
     *
     * @param url url
     * @return 是否需要302
     */
    public static boolean isForeignUrl(String url) {
        if (!TextUtils.isEmpty(url) && !UrlUtils.isBaiduDomain(url) && !url.startsWith("search:")) {
            return true;
        }
        return false;
    }

    /**
     * 获取重定向url
     *
     * @param url url
     * @return url
     */
    public static String getRedirectUrl(String url) {
        String rtnUrl = AppConfig.getRedirectUrl() + Uri.encode(url);
        rtnUrl = BaiduIdentityManager.getInstance(SearchBox.getAppContext()).processUrl(rtnUrl);
        return rtnUrl;
    }

    /**
     * 是否是已经加上前缀的重定向url
     *
     * @param url 判断的url
     * @return 是否是黄反重定向url
     */
    public static boolean isRedirectUrl(String url) {
        if (!TextUtils.isEmpty(url) && url.startsWith(AppConfig.getRedirectUrl())) {
            return true;
        }
        return false;
    }

    /**
     * 获取黄反重定向前的url 如果不是黄反重定向则返回原url
     *
     * @param url 需要提取的url
     * @return url
     */
    public static String getRemoveRedirectUrl(String url) {
        String rtnUrl = url;
        if (!TextUtils.isEmpty(url) && url.startsWith(AppConfig.getRedirectUrl())) {
            rtnUrl = getUrlField(url, "src");
            rtnUrl = Uri.decode(rtnUrl);
        }
        return rtnUrl;
    }

    /**
     * 判断一个字符串是否为符合粗粒度规则{@link Patterns#COARSE_GRAINED_WEB_URL}的Url
     *
     * @param query 待检查的字符串
     * @return 是否是符合规则的Url
     */
    @PluginAccessable(methodName = "isCoarseGrainedUrl", paramClasses = { String.class })
    public static boolean isCoarseGrainedUrl(String query) {
        Matcher matcher = Patterns.COARSE_GRAINED_WEB_URL.matcher(query);
        return matcher.matches();
    }

    // add by fujiaxing 201205010 END>

    // <add by fujiaxing 20120522 BEGIN
    /**
     * 对url进行校正.
     *
     * @param inUrl 输入的url
     * @return 输出的url
     */
    @PluginAccessable(methodName = "fixUrl", paramClasses = { String.class })
    public static String fixUrl(String inUrl) {
        // Converting the url to lower case
        // duplicates functionality in smartUrlFilter().
        // However, changing all current callers of fixUrl to
        // call smartUrlFilter in addition may have unwanted
        // consequences, and is deferred for now.
        if (inUrl == null) {
            return "";
        }
        int colon = inUrl.indexOf(':');
        boolean allLower = true;
        for (int index = 0; index < colon; index++) {
            char ch = inUrl.charAt(index);
            if (!Character.isLetter(ch)) {
                break;
            }
            allLower &= Character.isLowerCase(ch);
            if (index == colon - 1 && !allLower) {
                inUrl = inUrl.substring(0, colon).toLowerCase() + inUrl.substring(colon);
            }
        }
        if (inUrl.startsWith("http://") || inUrl.startsWith("https://") || inUrl.startsWith("rtsp://")) {
            return inUrl;
        }
        if (inUrl.startsWith("http:") || inUrl.startsWith("https:") || inUrl.startsWith("rtsp:")) {
            if (inUrl.startsWith("http:/") || inUrl.startsWith("https:/") || inUrl.startsWith("rtsp:/")) {
                inUrl = inUrl.replaceFirst("/", "//");
            } else {
                inUrl = inUrl.replaceFirst(":", "://");
            }
        }
        return inUrl;
    }

    // add by fujiaxing 20120522 END>
    /**
     * 根据uri，取出相应的电话号码
     *
     * @param c context
     * @param contactsUri 联系人的uri
     * @return 电话号码
     */
    @PluginAccessable(methodName = "getPhoneNumber", paramClasses = { Context.class, Uri.class })
    public static String getPhoneNumber(Context c, Uri contactsUri) {
        Context context = SearchBox.getAppContext();
        String retStr = null;
        Cursor contactsCur = null;
        Cursor phoneNumberCur = null;
        int contactId = 0;
        String phoneNumber;

        String[] selPhoneCols = new String[] { ContactsContract.CommonDataKinds.Phone.NUMBER };
        try {
            if (contactsUri != null) {
                contactsCur = context.getContentResolver().query(contactsUri, null, null, null, null);
                if (contactsCur != null && contactsCur.getCount() > 0) {
                    contactsCur.moveToFirst();
                    contactId = contactsCur.getInt(contactsCur.getColumnIndex(ContactsContract.Contacts._ID));

                    phoneNumberCur =
                            context.getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
                                    selPhoneCols, ContactsContract.CommonDataKinds.Phone.CONTACT_ID + "=" + contactId,
                                    null, null);

                    if (phoneNumberCur != null && phoneNumberCur.getCount() > 0) {
                        phoneNumberCur.moveToFirst();
                        phoneNumber = null;
                        do {
                            phoneNumber = phoneNumberCur.getString(0);
                            if (checkPhoneNumber(phoneNumber)) {
                                break;
                            }
                        } while (phoneNumberCur.moveToNext());

                        retStr = phoneNumber;
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (contactsCur != null) {
                contactsCur.close();
                contactsCur = null;
            }

            if (phoneNumberCur != null) {
                phoneNumberCur.close();
                phoneNumberCur = null;
            }
        }

        return retStr;
    }

    /**
     * This pattern is intended for searching for things that look like they might be phone numbers in arbitrary text,
     * not for validating whether something is in fact a phone number. It will miss many things that are legitimate
     * phone numbers.
     *
     * <p>
     * The pattern matches the following:
     * <ul>
     * <li>Optionally, a + sign followed immediately by one or more digits. Spaces, dots, or dashes may follow.
     * <li>Optionally, sets of digits in parentheses, separated by spaces, dots, or dashes.
     * <li>A string starting and ending with a digit, containing digits, spaces, dots, and/or dashes.
     * </ul>
     */
    public static final Pattern PHONE
    // sdd = space, dot, or dash
    = Pattern.compile("(\\+[0-9]+[\\- \\.]*)?" // +<digits><sdd>*
            + "(\\([0-9]+\\)[\\- \\.]*)?" // (<digits>)<sdd>*
            + "([0-9][0-9\\- \\.][0-9\\- \\.]+[0-9])"); // <digit><digit|sdd>+<digit>

    /**
     * 检查电话号码是否合法
     *
     * @param phoneNumber 电话号码
     * @return 合法与否
     */
    @PluginAccessable(methodName = "checkPhoneNumber", paramClasses = { String.class })
    public static boolean checkPhoneNumber(String phoneNumber) {

        if (TextUtils.isEmpty(phoneNumber)) {
            return false;
        }

        // add by qiaopu 先trim
        phoneNumber = phoneNumber.trim();

        if (phoneNumber.length() == 0) {
            return false;
        }
        // end add

        Matcher matcher = PHONE.matcher(phoneNumber);
        boolean ismatch = matcher.matches();

        return ismatch;
    }

    /**
     * 根据Bitmap获取其字节数据。
     *
     * @param bmp Bitmap.
     * @return 字节数据。
     */
    @PluginAccessable(methodName = "getBitmapData", paramClasses = { Bitmap.class })
    public static byte[] getBitmapData(Bitmap bmp) {
        if (bmp == null) {
            return new byte[0];
        }

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] ret = null;
        final int quality = 100;
        try {
            bmp.compress(Bitmap.CompressFormat.PNG, quality, out);
            ret = out.toByteArray();
            return ret;
        } finally {
            closeSafely(out);
        }
    }

    // 从ding searchable移动过来 BEGIN
    /**
     * 网络是否可用。(
     *
     * @param context context
     * @return 连接并可用返回 true
     */
    @PluginAccessable(methodName = "isNetworkConnected", paramClasses = { Context.class })
    public static boolean isNetworkConnected(Context context) {
        NetworkInfo networkInfo = getActiveNetworkInfo(SearchBox.getAppContext());
        // return networkInfo != null && networkInfo.isConnected();
        boolean flag = networkInfo != null && networkInfo.isAvailable();
        if (DEBUG) {
            Log.d(TAG, "isNetworkConnected, rtn: " + flag);
        }
        return flag;
    }

    /**
     * wifi网络是否可用
     *
     * @param context context
     * @return wifi连接并可用返回 true
     */
    @PluginAccessable(methodName = "isWifiNetworkConnected", paramClasses = { Context.class })
    public static boolean isWifiNetworkConnected(Context context) {
        NetworkInfo networkInfo = getActiveNetworkInfo(SearchBox.getAppContext());
        // return networkInfo != null && networkInfo.isConnected();
        boolean flag =
                networkInfo != null && networkInfo.isAvailable()
                        && networkInfo.getType() == ConnectivityManager.TYPE_WIFI;
        if (DEBUG) {
            Log.d(TAG, "isWifiNetworkConnected, rtn: " + flag);
        }
        return flag;

    }

    /**
     * 数据网络是否可用
     *
     * @param context context
     * @return 数据网络连接并可用返回 true
     */
    @PluginAccessable(methodName = "isMobileNetworkConnected", paramClasses = { Context.class })
    public static boolean isMobileNetworkConnected(Context context) {
        NetworkInfo networkInfo = getActiveNetworkInfo(SearchBox.getAppContext());
        boolean flag =
                networkInfo != null && networkInfo.isAvailable()
                        && networkInfo.getType() == ConnectivityManager.TYPE_MOBILE;
        if (DEBUG) {
            Log.d(TAG, "isMobileNetworkConnected, rtn: " + flag);
        }
        return flag;

    }

    /**
     * 判断是否为wap网络
     *
     * @param context Context
     * @return 连接可用，并且是Wap网络为true
     */
    public static boolean isWapNetWorkConnected(Context context) {
        ConnectManager cm = new ConnectManager(SearchBox.getAppContext());
        return cm.isWapNetwork();

    }

    /**
     * 获取活动的连接。
     *
     * @param context context
     * @return 当前连接
     */
    @PluginAccessable(methodName = "getActiveNetworkInfo", paramClasses = { Context.class })
    public static NetworkInfo getActiveNetworkInfo(Context context) {
        ConnectivityManager connectivity =
                (ConnectivityManager) SearchBox.getAppContext().getSystemService(Context.CONNECTIVITY_SERVICE);
        if (connectivity == null) {
            return null;
        }
        return connectivity.getActiveNetworkInfo();
    }

    /**
     * 解决activity关闭前调用前 settext()，导致edittext的popwindow失去window，引发崩溃.
     *
     * @param editText EditText
     * @param word 设置的文本.
     */
    @PluginAccessable(methodName = "setText", paramClasses = { EditText.class, String.class })
    public static void setText(EditText editText, String word) {
        if (editText != null && editText.getEditableText() != null) {
            editText.getEditableText().replace(0, editText.getText().length(), word);

        }
    }

    // <add by fujiaxing 从掌百拿过来 BEGIN
    /**
     * 获取url中的某个字段，字段定义：&fieldName=fieldValue
     *
     * @param url : String
     * @param fieldName : 字段名
     * @return fieldValue 字段值
     */
    @PluginAccessable(methodName = "getUrlField", paramClasses = { String.class, String.class })
    public static String getUrlField(String url, String fieldName) {
        return getUrlField(url, fieldName, "=", "&");
    }

    /**
     * 获取url中的某个字段，字段定义：fieldName=fieldValue
     *
     * @param url : String
     * @param fieldName : 字段名
     * @param keyvalueDivider : key与value直接的连接符
     * @param divideStr ： 分隔字符串
     *
     * @return fieldValue 字段值
     */
    @PluginAccessable(methodName = "getUrlField", paramClasses = { String.class, String.class, String.class,
            String.class })
    public static String getUrlField(String url, String fieldName, String keyvalueDivider, String divideStr) {
        if (TextUtils.isEmpty(url) || TextUtils.isEmpty(fieldName) || TextUtils.isEmpty(keyvalueDivider)
                || TextUtils.isEmpty(divideStr)) {
            return "";
        }

        fieldName = fieldName + keyvalueDivider;

        // 不转换为小写，避免pu参数是urlencode的情况，将%2C之类的转成%2c，导致替换失败
        // String tmp = url.toLowerCase();
        String tmp = url;
        int index = tmp.indexOf("?");
        if (index == -1) {
            index = 0;
        }

        int p = tmp.indexOf(fieldName, index);
        int q;
        if (p != -1) {
            q = tmp.indexOf(divideStr, p);
            if (q != -1) {
                tmp = tmp.substring(p + fieldName.length(), q);
            } else {
                tmp = tmp.substring(p + fieldName.length());
            }
            // 不decode，避免pu参数是urlencode的情况，decode导致替换失败
            // return Uri.decode(tmp);
            return tmp;
        }
        return "";
    }

    // add by fujiaxing 20120703 END>

    /**
     * 根据url和key获取对应的value
     *
     * @param manager BCookieManager
     * @param url domain
     * @param key key
     * @return value
     */
    public static String getCookieValue(BCookieManager manager, String url, String key) {
        if (manager == null) {
            return null;
        }
        String value = null;
        String cookie = manager.getCookie(url);

        if (!TextUtils.isEmpty(cookie)) {
            String[] cookies = cookie.split(";");
            int len = cookies.length;

            String keyValue = null;
            String[] keyValues = null;
            for (int i = 0; i != len; ++i) {
                keyValue = cookies[i].trim();
                keyValues = keyValue.split("=");
                if (keyValues.length == 2 && TextUtils.equals(key, keyValues[0])) {
                    value = keyValues[1];
                    break;
                }
            }
        }

        return value;
    }

    /**
     * 生成cookie的string
     *
     * @param domian domian
     * @param key cookie的key
     * @param value cookie设置的值
     * @param maxAge max-age 单位是秒，参照rfc2109，http://www.ietf.org/rfc/rfc2109.txt Max-Age=delta-seconds Optional. The
     *            Max-Age attribute defines the lifetime of the cookie, in seconds. The delta-seconds value is a decimal
     *            non- negative integer. After delta-seconds seconds elapse, the client should discard the cookie. A
     *            value of zero means the cookie should be discarded immediately.
     * @return cookie的string
     */
    public static String getCookieStr(String domian, String key, String value, long maxAge) {
        String cookieStr = key + "=" + value + ";" + "domain=" + domian + ";" + "path=/;" + "max-age=" + maxAge + ";";
        return cookieStr;

    }

    /**
     * 将byte数组写入文件
     *
     * @param data byte数组
     * @param file 文件
     * @return 是否写入成功的标志
     * @deprecated 请使用 lib-util 下的 {@link StreamUtils#bytesToFile(byte[], File)}
     */
    @Deprecated
    @PluginAccessable(methodName = "bytesToFile", paramClasses = { byte[].class, File.class })
    public static boolean bytesToFile(byte[] data, File file) {
        return StreamUtils.bytesToFile(data, file);
    }

    /**
     * stream to bytes
     *
     * @param is inputstream
     * @return bytes
     * @deprecated 请使用 lib-util 下的 {@link StreamUtils#streamToBytes(InputStream)}
     */
    @Deprecated
    @PluginAccessable(methodName = "streamToBytes", paramClasses = { InputStream.class })
    public static byte[] streamToBytes(InputStream is) {
        return StreamUtils.streamToBytes(is);
    }

    /**
     * 转换Stream成string
     *
     * @param is Stream源
     * @return 目标String
     * @deprecated 请使用 lib-util 下的 {@link StreamUtils#streamToString(InputStream)}
     */
    @Deprecated
    @PluginAccessable(methodName = "streamToString", paramClasses = { InputStream.class })
    public static String streamToString(InputStream is) {
        return StreamUtils.streamToString(is);
    }

    /**
     * 按照特定的编码格式转换Stream成string
     *
     * @param is Stream源
     * @param enc 编码格式
     * @return 目标String
     * @deprecated 请使用 lib-util 下的 {@link StreamUtils#streamToString(InputStream, String)}
     */
    @Deprecated
    @PluginAccessable(methodName = "streamToString", paramClasses = { InputStream.class, String.class })
    public static String streamToString(InputStream is, String enc) {
        return StreamUtils.streamToString(is, enc);
    }

    /**
     * 将输入流中的数据保存到文件
     *
     * @param is 输入流
     * @param file 目标文件
     * @return true:保存成功，false:保存失败
     * @deprecated 请使用 lib-util 下的 {@link StreamUtils#streamToFile(InputStream, File)}
     */
    @Deprecated
    @PluginAccessable(methodName = "streamToFile", paramClasses = { InputStream.class, File.class })
    public static boolean streamToFile(InputStream is, File file) {
        return StreamUtils.streamToFile(is, file);
    }

    /**
     * 从asset文件夹中复制文件到目标目录
     *
     * @param amgr AssetManager
     * @param src asset文件目录
     * @param dst 目标目录
     * @return true:复制成功； false:复制失败
     */
    @PluginAccessable(methodName = "extractFileFromAsset", paramClasses = { AssetManager.class, String.class,
            String.class })
    public static boolean extractFileFromAsset(AssetManager amgr, String src, String dst) {
        boolean bRet = false;
        try {
            bRet = streamToFile(amgr.open(src, Context.MODE_PRIVATE), new File(dst));
            if (!bRet) {
                new File(dst).delete();
            }
        } catch (IOException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        }
        return bRet;
    }

    /**
     * 从asset目标文件夹中复制所有文件至指定目录
     *
     * @param amgr AssetManager
     * @param srcFolder asset文件夹目录
     * @param dstFolder 目标文件加目录
     * @return true 复制成功
     */
    public static boolean extractFolderFromAsset(AssetManager amgr, String srcFolder, String dstFolder) {
        boolean bRet = false;
        try {
            String[] subFolders = amgr.list(srcFolder);
            String[] grandSubFolders;
            String subFolder;
            for (String folder : subFolders) {
                subFolder = srcFolder + File.separator + folder;
                grandSubFolders = amgr.list(subFolder);

                if (DEBUG) {
                    Log.d(TAG, "extractFolderFromAsset srcFolder: " + srcFolder + " subFolder: " + subFolder + " "
                            + "dstFolder: " + dstFolder);
                }

                if (grandSubFolders == null || grandSubFolders.length == 0) {
                    bRet = extractFileFromAsset(amgr, subFolder, dstFolder + File.separator + folder);
                } else {
                    bRet = extractFolderFromAsset(amgr, subFolder, dstFolder + File.separator + folder);
                }

                if (!bRet) {
                    break;
                }
            }
        } catch (IOException ioe) {
            if (DEBUG) {
                ioe.printStackTrace();
            }
        }

        return bRet;
    }

    /** 根据系统时间生成文件名的格式 */
    private static SimpleDateFormat sDateFormat = null;

    /**
     * 根据系统时间生成文件名
     *
     * @param suffix 文件后缀名
     * @return 文件名
     */
    @PluginAccessable(methodName = "createFileName", paramClasses = { String.class })
    public static synchronized String createFileName(String suffix) {
        if (null == sDateFormat) {
            sDateFormat = new SimpleDateFormat("yyyy_MM_dd-HH_mm_ss-SSS");
        }
        Date date = new Date();
        return String.format("%s.%s", sDateFormat.format(date), suffix);
    }

    /**
     * @param convertPlus true to convert '+' to ' '.
     * @param s s
     * @param charset charset
     * @throws UnsupportedEncodingException UnsupportedEncodingException
     * @return decodestring
     */
    @PluginAccessable(methodName = "decode", paramClasses = { String.class, boolean.class, String.class })
    public static String decode(String s, boolean convertPlus, String charset) throws UnsupportedEncodingException {
        if (s.indexOf('%') == -1 && (!convertPlus || s.indexOf('+') == -1)) {
            return s;
        }

        StringBuilder result = new StringBuilder(s.length());
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        try {
            for (int i = 0; i < s.length();) {
                char c = s.charAt(i);
                if (c == '%') {
                    do {
                        if (i + 2 >= s.length()) {
                            throw new IllegalArgumentException("Incomplete % sequence at: " + i);
                        }
                        int d1 = hexToInt(s.charAt(i + 1));
                        int d2 = hexToInt(s.charAt(i + 2));
                        if (d1 == -1 || d2 == -1) {
                            throw new IllegalArgumentException("Invalid % sequence "
                                    + s.substring(i, i + 3) + " at " + i); // SUPPRESS CHECKSTYLE
                        }
                        out.write((byte) ((d1 << 4) + d2)); // SUPPRESS CHECKSTYLE
                        i += 3; // SUPPRESS CHECKSTYLE
                    } while (i < s.length() && s.charAt(i) == '%');
                    result.append(new String(out.toByteArray(), charset));
                    out.reset();
                } else {
                    if (convertPlus && c == '+') {
                        c = ' ';
                    }
                    result.append(c);
                    i++;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            closeSafely(out);
        }
        return result.toString();
    }

    /**
     * Like {@link Character#digit}, but without support for non-ASCII characters.
     *
     * @param c c
     * @return hex int
     */
    private static int hexToInt(char c) {
        if ('0' <= c && c <= '9') {
            return c - '0';
        } else if ('a' <= c && c <= 'f') {
            return 10 + (c - 'a'); // SUPPRESS CHECKSTYLE
        } else if ('A' <= c && c <= 'F') {
            return 10 + (c - 'A'); // SUPPRESS CHECKSTYLE
        } else {
            return -1;
        }
    }

    /**
     * 将字符数组转换为字节数组，
     *
     * @param data 字节数组
     * @return 字符数组
     */
    public static byte[] decodeHex(char[] data) {
        int len = data.length;
        if ((len & 0x01) != 0) {
            if (DEBUG) {
                throw new RuntimeException("Odd number of characters.");
            } else {
                return null;
            }
        }
        byte[] out = new byte[len >> 1];
        // two characters form the hex value.
        try {
            for (int i = 0, j = 0; j < len; i++) {
                int f = toDigit(data[j], j) << 4; // SUPPRESS CHECKSTYLE
                j++;
                f = f | toDigit(data[j], j);
                j++;
                out[i] = (byte) (f & 0xFF); // SUPPRESS CHECKSTYLE
            }
        } catch (RuntimeException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
            return null;
        }
        return out;
    }

    /* *
     * Convert byte[] to hex string.
     *
     * @param src byte[] data
     *
     * @return hex string
     */
    public static String bytesToHexString(byte[] src) {
        StringBuilder stringBuilder = new StringBuilder("");
        if (src == null || src.length <= 0) {
            return null;
        }
        for (int i = 0; i < src.length; i++) {
            int v = src[i] & 0xFF;
            String hv = Integer.toHexString(v);
            if (hv.length() < 2) {
                stringBuilder.append(0);
            }
            stringBuilder.append(hv);
        }
        return stringBuilder.toString();
    }

    /**
     * 将十六进制字符转换成一个整数
     *
     * @param ch 十六进制char
     * @param index 十六进制字符在字符数组中的位置
     * @return 一个整数
     */
    private static int toDigit(char ch, int index) {
        int digit = Character.digit(ch, 16); // SUPPRESS CHECKSTYLE
        if (digit == -1) {
            throw new RuntimeException("Illegal hexadecimal character " + ch + " at index " + index);
        }
        return digit;
    }

    /**
     * 设置屏幕的density
     *
     * @param context context
     */
    public static void setScreenDensity(Context context) {
        DisplayMetrics dm = new DisplayMetrics();
        ((Activity) context).getWindowManager().getDefaultDisplay().getMetrics(dm);
        mDensity = dm.densityDpi;
        mFloatDensity = dm.density;
    }

    /**
     * 获取屏幕density
     *
     * @return density
     */
    @PluginAccessable(methodName = "getScreenDensity", paramClasses = {})
    public static int getScreenDensity() {
        return mDensity;
    }

    /**
     * 获取屏幕density
     *
     * @return density
     */
    @PluginAccessable(methodName = "getScreenFloatDensity", paramClasses = {})
    public static float getScreenFloatDensity() {
        return mFloatDensity;
    }

    // 合并OEM patch 20120904 BEGIN
    /**
     * 获取签名信息
     *
     * @param context : 上下文
     * @param pkgName package name
     * @return 签名String
     */
    public static String getSign(Context context, String pkgName) {
        PackageManager pm = context.getPackageManager();
        // modify by qiaopu 2012-12-06 改进获取签名的方法
        // List<PackageInfo> apps = pm
        // .getInstalledPackages(PackageManager.GET_SIGNATURES);
        //
        // Iterator<PackageInfo> iter = apps.iterator();
        //
        // PackageInfo info;
        // while (iter.hasNext()) {
        // info = iter.next();
        //
        // // 按包名取签名
        // if (TextUtils.equals(info.packageName, pkgName)) {
        // if (info.signatures.length > 0) {
        // return info.signatures[0].toCharsString();
        // }
        // }
        // }
        // return "";

        String sign = "";
        try {
            PackageInfo packageInfo = pm.getPackageInfo(pkgName, PackageManager.GET_SIGNATURES);

            if (packageInfo != null && packageInfo.signatures.length > 0) {
                sign = packageInfo.signatures[0].toCharsString();
            }

        } catch (Exception e) {
            if (SearchBox.DEBUG) {
                Log.e(TAG, "get sign error!!!", e);
            }
        }

        return sign;
        // end modify
    }

    // 合并OEM patch 20120904 END

    /**
     * 通过Permission获取签名
     *
     * @param context context
     * @param permission permission
     * @return 签名
     */
    public static String getSignByPermission(Context context, String permission) {
        PackageManager pm = context.getPackageManager();
        String pkgName = "";
        try {
            // 检查哪个package定义了该signature级别权限.
            PermissionInfo pi = pm.getPermissionInfo(permission, PackageManager.GET_META_DATA);
            pkgName = pi.packageName;

        } catch (Exception e) {
            if (SearchBox.DEBUG) {
                Log.e(TAG, "get packageName error!!!", e);
            }
        }

        if (TextUtils.isEmpty(pkgName)) {
            return pkgName;
        }

        // 读取该package的签名
        return getSign(context, pkgName);
    }

    /**
     * server如果下发为gip，则获取gzip inputstream .
     *
     * @param resEntity {@link HttpEntity}
     * @return gzip InputStream or null
     * @throws IOException {@link IOException}
     */
    @PluginAccessable(methodName = "getGzipInputStream", paramClasses = { HttpEntity.class })
    public static InputStream getGzipInputStream(HttpEntity resEntity) throws IOException {
        Header header = resEntity.getContentEncoding();
        String contentEncoding = null;
        InputStream inputStream = null;
        if (header != null) {
            contentEncoding = header.getValue();
            if (contentEncoding.toLowerCase().indexOf("gzip") != -1) {
                inputStream = new GZIPInputStream(resEntity.getContent());
            }
        }

        return inputStream;
    }

    /**
     * 根据server下发的Content-Encoding，获取适当的inputstream.当content-encoding为gzip时，返回GzipInputStream 否则返回原有的inputStream
     *
     * @param resEntity {@link HttpEntity}
     * @return InputStream or null
     * @throws IOException {@link IOException}
     */
    @PluginAccessable(methodName = "getSuitableInputStream", paramClasses = { HttpEntity.class })
    public static InputStream getSuitableInputStream(HttpEntity resEntity) throws IOException {
        if (resEntity == null) {
            return null;
        }
        InputStream inputStream = resEntity.getContent();
        if (inputStream != null) {
            Header header = resEntity.getContentEncoding();
            if (header != null) {
                String contentEncoding = header.getValue();
                if (!TextUtils.isEmpty(contentEncoding) && contentEncoding.toLowerCase().indexOf("gzip") > -1) {
                    inputStream = new GZIPInputStream(inputStream);
                }
            }
        }
        return inputStream;
    }

    /**
     * 解析server传输的base64编码icon数据
     *
     * @param attribute base64编码数据
     * @return 解码数据
     */
    @PluginAccessable(methodName = "parseIconData", paramClasses = { String.class })
    public static String parseIconData(String attribute) {
        attribute = attribute.replaceFirst("data:image/.+;base64,", "");
        attribute = attribute.trim();
        return attribute;
    }

    /**
     * 等地理位置信息到达,情景推送收到定位指令会立即定位
     *
     * @param context 句柄
     * @param maxDuration 最大等待时间
     *
     */
    @PluginAccessable(methodName = "waitLocationIfNeedInPush", paramClasses = { Context.class, long.class })
    public static void waitLocationIfNeedInPush(Context context, long maxDuration) {
        if (maxDuration <= 0 || maxDuration > SearchBoxLocationManager.SDK_LOCATION_TIMEOUT) {
            maxDuration = SearchBoxLocationManager.SDK_LOCATION_TIMEOUT;
        }
        final long oneSleep = 200;
        maxDuration = maxDuration - oneSleep; // 保证不超过max duration

        SearchBoxLocationManager locationManager = SearchBoxLocationManager.getInstance(SearchBox.getAppContext());
        if (!locationManager.isLocating()) { // 如果没有处在定位中，启动定位
            locationManager.requestLocation();
        }

        // 每隔一段时间看看是否定位结束
        long startTime = System.currentTimeMillis();
        while (locationManager.isLocating() && (System.currentTimeMillis() - startTime) <= maxDuration) {
            try {
                Thread.sleep(oneSleep);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    // <add by fjx BEGIN
    /**
     * url encode string。避免用到的地方都需要try一下
     *
     * @param str 待encode string
     * @return encoded string or original string if exception.
     */
    @PluginAccessable(methodName = "encodeStr", paramClasses = { String.class })
    public static String encodeStr(String str) {
        try {
            str = URLEncoder.encode(str, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return str;
    }

    /**
     * 为了防止大家不给线程起名字，写此静态函数.目的是当发生线程泄漏后能够快速定位问题.
     *
     * @param r Runnable
     * @param name 线程名
     * @return Thread
     */
    public static Thread newThread(Runnable r, String name) {
        if (TextUtils.isEmpty(name)) {
            throw new RuntimeException("thread name should not be empty");
        }
        return new Thread(r, getStandardThreadName(name));
    }

    // add by fjx END>
    /**
     * 获取标准线程名
     *
     * @param name 线程名
     * @return 处理过的线程名
     */
    public static String getStandardThreadName(String name) {
        if (name != null) {
            final String PREFIX = "BDSB_";
            if (!name.startsWith(PREFIX)) {
                return PREFIX + name;
            }
        }
        return name;
    }

    /**
     * 缓存文件
     *
     * @param context Context Object
     * @param file 本地文件名
     * @param data 要保存的数据
     * @param mode 打开文件的方式
     * @return 是否保存成功
     */
    @PluginAccessable(methodName = "cache", paramClasses = { Context.class, String.class, String.class, int.class })
    public static boolean cache(Context context, String file, String data, int mode) {
        return cache(context, file, data.getBytes(), mode);
    }

    /**
     * 缓存文件
     *
     * @param context Context Object
     * @param file 本地文件名
     * @param data 要保存的数据
     * @param mode 打开文件的方式
     * @return 是否保存成功
     */
    @PluginAccessable(methodName = "cache", paramClasses = { Context.class, String.class, byte[].class, int.class })
    public static boolean cache(Context context, String file, byte[] data, int mode) {
        boolean bResult = false;
        if (null == data) {
            data = new byte[0];
        }

        FileOutputStream fos = null;
        try {
            fos = context.openFileOutput(file, mode);
            fos.write(data);
            fos.flush();
            bResult = true;
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (null != fos) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        return bResult;
    }

    /**
     * 删除缓存文件，通常这个文件是存在应用程序的系统数据目录里面，典型的目录是data/data/package-name/files
     *
     * @param context context
     * @param name 本地文件名，不要包含路径分隔符
     * @return true：成功，false：失败
     */
    @PluginAccessable(methodName = "deleteCache", paramClasses = { Context.class, String.class })
    public static boolean deleteCache(Context context, String name) {
        boolean succeed = false;

        try {
            succeed = context.deleteFile(name);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return succeed;
    }

    /**
     * 读取缓存文件中的数据
     *
     * @param context 上下文
     * @param file 文件名
     * @return 文件中的字符串数据
     */
    @PluginAccessable(methodName = "readCacheData", paramClasses = { Context.class, String.class })
    public static String readCacheData(Context context, String file) {
        FileInputStream fis = null;
        StringBuilder sb = new StringBuilder();
        try {
            fis = context.openFileInput(file);
            BufferedReader br = new BufferedReader(new InputStreamReader(fis));

            String str = "";
            while ((str = br.readLine()) != null) {
                sb.append(str);
            }
            return sb.toString();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return "";
        } catch (IOException e) {
            e.printStackTrace();
            return "";
        } finally {
            if (null != fis) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * 判断文件是否是存在
     *
     * @param context context
     * @param fileName fileName
     * @return 是否存在
     */
    @PluginAccessable(methodName = "isCacheFileExist", paramClasses = { Context.class, String.class })
    public static boolean isCacheFileExist(Context context, String fileName) {
        if (context != null && !TextUtils.isEmpty(fileName)) {
            File file = new File(context.getFilesDir(), fileName);
            try {
                return file.exists();
            } catch (SecurityException e) {
                return false;
            }
        }
        return false;
    }

    /**
     * 把内容复制到剪切板
     *
     * @author liudongqi
     * @since 2013-1-8
     * @param text 复制到剪切板的内容
     * @param context context
     */
    @PluginAccessable(methodName = "copyToClipboard", paramClasses = { String.class, Context.class })
    public static void copyToClipboard(final String text, Context context) {
        WrappedClipboardManager clipboard = WrappedClipboardManager.newInstance(context.getApplicationContext());
        clipboard.setText(text);
        Toast.makeText(context, R.string.text_selection_ok_tip, Toast.LENGTH_SHORT).show();
        /*
         * if (android.os.Build.VERSION.SDK_INT <= android.os.Build.VERSION_CODES.HONEYCOMB) { // api level < 11
         *
         * @SuppressWarnings("deprecation") android.text.ClipboardManager clipboard = (android.text.ClipboardManager)
         * context.getApplicationContext().getSystemService( Context.CLIPBOARD_SERVICE); if (clipboard != null) {
         * clipboard.setText(text); Toast.makeText(context, R.string.text_selection_ok_tip, Toast.LENGTH_SHORT).show();
         * } } else { // api level >= 11 android.content.ClipboardManager clipboard = (android.content.ClipboardManager)
         * context.getApplicationContext().getSystemService( Context.CLIPBOARD_SERVICE); if (clipboard != null) {
         * clipboard.setText(text); Toast.makeText(context, R.string.text_selection_ok_tip, Toast.LENGTH_SHORT).show();
         * } }
         */
    }

    /**
     * 添加书签
     *
     * @author lisen02
     * @since 2013-3-4
     * @param context Context
     * @param title 书签标题
     * @param url 书签链接
     */
    @PluginAccessable(methodName = "addBookmark", paramClasses = { Context.class, String.class, String.class })
    public static void addBookmark(Context context, String title, String url) {
        Intent intent = new Intent();
        intent.setClass(context, BookmarkHistoryActivity.class);
        BookmarkItemData bookmark = new BookmarkItemData();
        bookmark.title = TextUtils.isEmpty(title) ? url : title;
        bookmark.setUrl(url);
        intent.putExtra(BookmarkHistoryActivity.WEBSITE_INFO, bookmark);
        startActivitySafely(context, intent);
    }

    /**
     * 在浏览页打开URL
     *
     * @author lisen02
     * @since 2013-3-4
     * @param context Context
     * @param url URL
     * @param fromHome 是否为主页上的链接
     * @param openInNewWindow 是否在新窗口中打开
     */
    @PluginAccessable(methodName = "loadUrl", paramClasses = { Context.class, String.class, boolean.class,
            boolean.class })
    public static void loadUrl(Context context, String url, boolean fromHome, boolean openInNewWindow) {
        Bundle extras = new Bundle();
        extras.putBoolean(Browser.EXTRA_URL_FROM_HOME, fromHome);
        extras.putString(Browser.KEY_URL, url);
        extras.putBoolean(Browser.EXTRA_URL_NEW_WINDOW, openInNewWindow);

        SearchBrowser.startBrowser(context, extras);
    }

    /**
     * 在搜索结果页中打开url
     *
     * @param context Context
     * @param url url
     * @param fromHome fromHome
     */
    public static void loadSearchUrl(Context context, String url, boolean fromHome) {
        Bundle extras = new Bundle();
        extras.putBoolean(Browser.EXTRA_URL_FROM_HOME, fromHome);
        extras.putString(Browser.KEY_URL, url);
        extras.putString(Browser.KEY_TARGET, TargetView.SEARCH.name());

        SearchBrowser.startSearch(context, extras);
    }

    /**
     * 用O2O框架调起url
     *
     * @param context {@link Context}
     * @param url 网址url
     * @param needAppendPublicParam 是否需要添加公共参数
     * @param appId 轻应用Id
     */
    @PluginAccessable(methodName = "loadUrlWithLightBrowser", paramClasses = { Context.class, String.class,
            boolean.class, String.class })
    public static void
            loadUrlWithLightBrowser(Context context, String url, boolean needAppendPublicParam, String appId) {
        LightBrowserActivity.startLightBrowserActivity(SearchBox.getAppContext(), url, appId, needAppendPublicParam);
    }

    /**
     * 用O2O框架调起url或者轻应用，使用的O2O框架在独立的activity栈上
     *
     * @param url 网址url
     * @param needAppendPublicParam 是否需要添加公共参数
     * @param appId 轻应用Id
     */
    @PluginAccessable(methodName = "loadUrlWithPluginStackLightBrowser", paramClasses = { String.class, boolean.class,
            String.class })
    public static void loadUrlWithPluginStackLightBrowser(String url, boolean needAppendPublicParam, String appId) {
        LightBrowserPluginStackActivity.startLightBrowserPluginStackActivity(SearchBox.getAppContext(), url, appId,
                needAppendPublicParam);
    }

    /**
     * 加载本地数据
     *
     * @author liudongqi
     * @since 2013-3-4
     * @param context Context
     * @param baseUrl baseUrl
     * @param content content
     * @param fromHome 是否为主页上的链接
     * @param openInNewWindow 是否在新窗口中打开
     * @param localUrl 本地数据url,用于back处理
     */
    @PluginAccessable(methodName = "loadDataWithBaseUrl", paramClasses = { Context.class, String.class, String.class,
            boolean.class, boolean.class, String.class })
    public static void loadDataWithBaseUrl(Context context, String baseUrl, String content, boolean fromHome,
            boolean openInNewWindow, String localUrl) {
        Bundle extras = new Bundle();
        extras.putBoolean(Browser.EXTRA_URL_FROM_HOME, fromHome);
        extras.putString(Browser.KEY_URL, baseUrl);
        extras.putString(Browser.EXTRA_LOAD_LOCALDATA_CONTENT, content);
        extras.putBoolean(Browser.EXTRA_URL_NEW_WINDOW, openInNewWindow);
        extras.putBoolean(Browser.EXTRA_LOAD_LOCALDATA, true);
        extras.putString(Browser.EXTRA_LOAD_LOCALDATA_URL, localUrl);
        SearchBrowser.startBrowser(context, extras);
    }

    /**
     * 识别图搜的预览帧数据
     * @param pixels 预览帧数据
     * @param width 预览帧宽度
     * @param height 预览帧高度
     * @param type 数据类型
     * @return
     */
    @PluginAccessable(methodName = "decodeBarcode", paramClasses = { byte[].class, int.class, int.class, BarcodeType
            .class })
    public static BarcodeResult decodeBarcode(byte[] pixels, int width, int height, BarcodeType type) {
        BarcodeResult barcodeResult = null;
        try {
            // 根据解析类型得到typeconf
            int typeconf = 0;
            switch (type) {
                case BAR_CODE:
                    typeconf = CONF_BARCODE;
                    break;
                case QR_CODE:
                    typeconf = Barcode.CONF_QRCODE;
                    break;
                case ALL:
                default:
                    typeconf = Barcode.CONF_QRCODE | CONF_BARCODE;
                    break;
            }
            barcodeResult = Barcode.decodeByte(pixels, width, height, typeconf);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return barcodeResult;
    }

    /**
     * 跳转扫码结果页
     * @param context 上下文
     * @param barcodeResult 结果
     * @return
     */
    @PluginAccessable(methodName = "handleBarcodeResult", paramClasses = { Context.class, BarcodeResult.class })
    public static void handleBarcodeResult(Context context, BarcodeResult barcodeResult) {
        Result result = new Result(barcodeResult);
        ResultHandlerInterface resultHandler = new ResultHandler(context);
        if (null != result) {
            boolean bHandled = preHandleResult(context, resultHandler, result);
            if (!bHandled && resultHandler != null) {
                bHandled = resultHandler.handleResultText(context, result.getText());
            }
            if (!bHandled) {
                Intent intent = new Intent(context, CodeScannerActivity.class);
                Bundle params = new Bundle();
                params.putByteArray("code", barcodeResult.code);
                params.putString("encoding", barcodeResult.encoding);
                params.putInt("codeType", barcodeResult.codeType);
                intent.putExtra("barcode_result", params);
                intent.putExtra("from", "godeye");
                context.startActivity(intent);
            }
        }
    }

    /**
     * 若扫描结果包含系统可直接处理的动作，则直接处理，如mailto:
     * @param context 上下文
     * @param resultHandler 结果处理器
     * @param parsedResult Parsed Result
     * @return 处理了，返回true，外面无需再处理；如果未处理，返回false
     */
    public static boolean preHandleResult(Context context, ResultHandlerInterface resultHandler, Result result) {
        boolean isHandled = false;
        if (resultHandler == null) {
            return false;
        }
        ParsedResult parsedResult = result.getParsedResult();
        switch (parsedResult.getType()) {
            case EMAIL_ADDRESS:
                EmailAddressParsedResult emailResult = (EmailAddressParsedResult) parsedResult;
                isHandled = resultHandler.handleSpecialScheme(context, emailResult.getMailtoURI());
                break;
            case URI:
                URIParsedResult uriResult = (URIParsedResult) parsedResult;
                isHandled = resultHandler.handleSpecialScheme(context, uriResult.getURI());
                break;
            case SMS:
                SMSParsedResult smsResult = (SMSParsedResult) parsedResult;
                isHandled = resultHandler.handleSpecialScheme(context, smsResult.getSMSURI());
                break;
            case TEXT:
                if (BarcodeType.BAR_CODE == result.getBarcodeType()) {
                    impl.requestBarcodeResult(context, result.getParsedResult().getDisplayResult(),
                            result.getBarcodeFormat().getValue());
                    isHandled = true;
                } else {
                    TextParsedResult textResult = (TextParsedResult) parsedResult;
                    isHandled = resultHandler.handleSpecialScheme(context, textResult.getText());
                }
                break;
            case PRODUCT:
            case ISBN:
                impl.requestBarcodeResult(context, result.getParsedResult().getDisplayResult(),
                        result.getBarcodeFormat().getValue());
                isHandled = true;
                break;
            default:
                isHandled = resultHandler.handleSpecialScheme(context, parsedResult.getDisplayResult());
                break;
        }
        return isHandled;
    }
    /**
     * 加载本地数据, 为语音搜索插件提供接口，在搜索框架打开
     *
     * @author shanghuibo
     * @since 2015-12-11
     * @param context Context
     * @param baseUrl baseUrl
     * @param content content
     * @param fromHome 是否为主页上的链接
     * @param openInNewWindow 是否在新窗口中打开
     * @param localUrl 本地数据url,用于back处理
     * @Param voiceResults 语音候选词
     * @Param corpusNo 标记语音识别会话id的Extra
     */
    @PluginAccessable(methodName = "loadDataWithBaseUrl", paramClasses = { Context.class, String.class, String.class,
            boolean.class, boolean.class, String.class, String[].class, String.class })
    public static void loadDataWithBaseUrl(Context context, String baseUrl, String content, boolean fromHome,
            boolean openInNewWindow, String localUrl, String[] voiceResults, String corpusNo) {
        if (DEBUG) {
            Log.d(TAG, "loadDataWithBaseUrl url = " + baseUrl);
            Log.d(TAG, "loadDataWithBaseUrl content = " + content);
        }

        Bundle extras = new Bundle();
        extras.putBoolean(Browser.EXTRA_URL_FROM_HOME, fromHome);
        extras.putString(Browser.KEY_URL, baseUrl);
//        extras.putString(Browser.EXTRA_LOAD_LOCALDATA_CONTENT, content);
        Browser.sLocalDataMap.put(baseUrl, content);
        extras.putBoolean(Browser.EXTRA_URL_NEW_WINDOW, openInNewWindow);
        extras.putBoolean(Browser.EXTRA_LOAD_LOCALDATA, true);
        extras.putString(Browser.EXTRA_LOAD_LOCALDATA_URL, localUrl);
        extras.putStringArray(FloatSearchBoxLayout.KEY_VOICE_SUGGESTIONS, voiceResults);
        extras.putString(VoiceSearch.EXTRA_CORPUS_NO, corpusNo);
        SearchBrowser.startSearch(context, extras);
    }

    /** unzip buffer size. */
    private static final int UNZIP_BUFFER = 2048;

    /**
     * unzip file.
     * 
     * @param srcFileName 源file绝对路径.
     * @param savePath 目标file父目录路径
     * @return boolean 是否解压成功
     */
    @PluginAccessable(methodName = "unzipFile", paramClasses = { String.class, String.class })
    public static boolean unzipFile(String srcFileName, String savePath) {
        long startTime = System.currentTimeMillis();
        if (srcFileName == null) {
            return false;
        }
        if (savePath == null) {
            savePath = new File(srcFileName).getParent();
        }

        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        try {
            ZipFile zipFile = new ZipFile(srcFileName);
            Enumeration<? extends ZipEntry> enu = zipFile.entries();

            while (enu.hasMoreElements()) {
                ZipEntry zipEntry = enu.nextElement();
                File saveFile = new File(savePath + "/" + zipEntry.getName());
                if (zipEntry.isDirectory()) {
                    if (!saveFile.exists()) {
                        saveFile.mkdirs();
                    }
                    continue;
                }
                if (!saveFile.exists()) {
                    saveFile.createNewFile();
                }
                bis = new BufferedInputStream(zipFile.getInputStream(zipEntry));
                FileOutputStream fos = new FileOutputStream(saveFile);
                bos = new BufferedOutputStream(fos, UNZIP_BUFFER);

                int count = -1;
                byte[] buf = new byte[UNZIP_BUFFER];
                while ((count = bis.read(buf, 0, UNZIP_BUFFER)) != -1) {
                    bos.write(buf, 0, count);
                }

                bos.flush();
            }
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        } finally {
            Utility.closeSafely(bos);
            Utility.closeSafely(bis);
            long endTime = System.currentTimeMillis();
            if (DEBUG) {
                Log.i(TAG, "unZip:" + srcFileName + "cost:" + (endTime - startTime) + "ms");
            }
        }
        return true;
    }

    /**
     * 删除文件，可以删除文件、文件夹及子目录、子文件
     * 
     * @param file 需要删除的文件或目录
     */
    @PluginAccessable(methodName = "deleteFile", paramClasses = { File.class })
    public static void deleteFile(File file) {
        if (file == null || !file.exists()) {
            return;
        }
        if (file.isFile()) {
            file.delete();
            return;
        }

        if (file.isDirectory()) {
            File[] childFile = file.listFiles();
            if (childFile == null || childFile.length == 0) {
                file.delete();
                return;
            }
            for (File f : childFile) {
                deleteFile(f);
            }
            file.delete();
        }
    }

    /**
     * 插件中进行tc打点统计调用接口
     * 
     * @param value 待拼接到url的参数
     */
    @PluginAccessable(methodName = "addTCStatisticInPlugin", paramClasses = { String.class })
    public static void addTCStatisticInPlugin(String value) {
        if (DEBUG) {
            Log.d(TAG, "addTCStatisticInPlugin: " + value);
        }
        if (TextUtils.isEmpty(value)) {
            return;
        }
        String url = AppConfig.getTCInPluginHost() + value;
        PluginStatistic.addTCStatisticInPlugin(SearchBox.getAppContext(), url);
    }

    /**
     * 根据Intent类型判断要显示的界面
     * 
     * @author lisen02
     * @since 2013-2-28
     * @param intent Intent
     * @return 要显示的界面类型 {@link TargetView}
     */
    public static TargetView getTargetView(Intent intent) {
        if (intent == null) {
            return TargetView.NONE;
        }
        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) == Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) {
            return TargetView.NONE;
        }

        String action = intent.getAction();
        if (TextUtils.isEmpty(action)) {
            return TargetView.NONE;
        }
        if (IntentConstants.ACTION_HOME.equals(action)) {
            if (!TextUtils.isEmpty(intent.getStringExtra(CardConstants.CARD_ITEM_CARD_ID))) {
                // 如果该intent是点击卡片提醒消息的intent，则指定回到首页卡片tab页
                intent.putExtra(HomeTabHostView.EXTRA_TARGET_TAB, HomeTabManager.getBaiduTabTag());
            }
            if (!TextUtils.isEmpty(intent.getStringExtra(HomeTabHostView.EXTRA_TARGET_TAB))) {
                return TargetView.TAB;
            }
            return TargetView.HOME;
        }
        if (Intent.ACTION_MAIN.equals(action)) {
            return TargetView.HOME;
        }

        if (TextUtils.equals(action, DingWidget.ACTION_FROM_WIDGET_PROVIDER)) {
            return TargetView.SEARCHFRAME;
        }

        // if (IntentConstants.ACTION_MULTIWINDOW.equals(action)) {
        // return TargetView.MULTIWINDOW;
        // }
        if (Intent.ACTION_SEARCH.equals(action)
                || Intent.ACTION_WEB_SEARCH.equals(action)
                || IntentConstants.ACTION_SEARCH.equals(action)
                || IntentConstants.ACTION_LIGHT_SEARCH.equals(action)
                || IntentConstants.ACTION_VOICE_SEARCH_RESULTS.equals(action)) {
            return TargetView.BROWSER;
        }

        if (IntentConstants.ACTION_VIEW.equals(action)
                || IntentConstants.ACTION_BROWSER.equals(action)
                || IntentConstants.ACTION_BOX_BROWSER.equals(action)) {

            String url = intent.getStringExtra(Browser.KEY_URL);
            if (TextUtils.isEmpty(url)) {
                url = intent.getDataString();
            }
            if (!TextUtils.isEmpty(url)) {
                String target = intent.getStringExtra(Browser.KEY_TARGET);
                if (!TextUtils.isEmpty(target)) {
                    try {
                        return TargetView.valueOf(target.trim().toUpperCase());
                    } catch (IllegalArgumentException e) {
                    }
                }
//                if (url.startsWith(Browser.SCHEME_SEARCH) || url.startsWith(Browser.SCHEME_ADD_WIDGET)) {
//                    return TargetView.SEARCH;
//                }
//
//                if (ShareUtils.checkSearchResultUrl(url)) {
//                    return TargetView.SEARCH;
//                }
//
//                if (isSearchBoxTcUrl(url)) {
//                    return TargetView.SEARCH;
//                }
            }
            if (DEBUG) {
                if (DebugFeturesTab.isOpenUrlWithLightSearch() || DebugFeturesTab.isOpenUrlWithSearch()) {
                    return TargetView.SEARCH;
                }
            }
            return TargetView.BROWSER;
        }
        if (IntentConstants.ACTION_LEAVE_AND_NOTICE.equals(action)) {
            return TargetView.PLUGIN;
        }
        // 其他情况
        return TargetView.NONE;
    }

    /**
     * 判断是否是通过tc跳转的搜索结果页
     *
     * @param url url
     * @return 是否是搜索结果页
     */
    private static boolean isSearchBoxTcUrl(String url) {
        if (TextUtils.isEmpty(url)) {
            return false;
        }

        String protocol = null;
        String host = null;
        String paths = null;
        String query = null;
        int port = -1;
        try {
            URL aURL = new URL(url);
            protocol = aURL.getProtocol();
            host = aURL.getHost();
            port = aURL.getPort();
            paths = aURL.getPath();
            query = aURL.getQuery();
        } catch (MalformedURLException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        }

        // 增加https wise将会切换https add by suixin
        if (!("http".equalsIgnoreCase(protocol) || "https".equalsIgnoreCase(protocol))
                || (!ShareUtils.M_BAIDU_HOST.equalsIgnoreCase(host) && !ShareUtils.isQASearchBoxHost(host, port))
                || paths == null || query == null) {
            return false;
        }

        if (!TextUtils.isEmpty(paths)) {
            if (paths.equalsIgnoreCase("/searchbox")) {
                if (!TextUtils.isEmpty(query)) {
                    String[] pairs = query.split("&");
                    HashMap<String, String> params = new HashMap<String, String>();
                    for (String pair : pairs) {
                        String[] splitPair = pair.split("=");
                        if (splitPair.length == 2) {
                            params.put(splitPair[0], splitPair[1]);
                        }
                    }

                    String action = params.get("action");
                    if (TextUtils.isEmpty(action) || !action.equalsIgnoreCase("tc")) {
                        return false;
                    }
                    String type = params.get("type");
                    if (TextUtils.isEmpty(type) || !type.equalsIgnoreCase("rct")) {
                        return false;
                    }

                    String src = params.get("src");
                    if (!TextUtils.isEmpty(src)) {
                        try {
                            String decodeSrc = URLDecoder.decode(src, "UTF-8");
                            if (decodeSrc.startsWith("search://")) {
                                return true;
                            }

                            if (ShareUtils.checkSearchResultUrl(decodeSrc)) {
                                return true;
                            }
                        } catch (UnsupportedEncodingException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
        return false;
    }
    /**
     * 根据手机的分辨率从 dp 的单位 转成为 px(像素)
     * 
     * @param context 上下文句柄
     * @param dpValue dp 的单位
     * @return px(像素)的单位
     */
    @PluginAccessable(methodName = "dip2px", paramClasses = { Context.class, float.class })
    public static int dip2px(Context context, float dpValue) {
        // final float scale = context.getResources().getDisplayMetrics().density;
        final float scale = getDensity(context);
        return (int) (dpValue * scale);
    }

    /**
     * 根据手机的分辨率从 px(像素) 的单位 转成为 dp
     */
    /**
     * 根据手机的分辨率从 px(像素) 的单位 转成为 dp
     * 
     * @param context 上下文句柄
     * @param pxValue px(像素) 的单位
     * @return dp的单位
     */
    @PluginAccessable(methodName = "px2dip", paramClasses = { Context.class, float.class })
    public static int px2dip(Context context, float pxValue) {
        // final float scale = context.getResources().getDisplayMetrics().density;
        final float scale = getDensity(context);
        return (int) (pxValue / scale);
    }

    /**
     * 判断外部存储是否可写
     * 
     * 此方法内采用文件读写操作来检测，所以相对比较耗时，请谨慎使用。
     * 
     * @return true:可写; false 不存在/没有mounted/不可写
     */
    @PluginAccessable(methodName = "isExternalStorageWriteable", paramClasses = {})
    public static boolean isExternalStorageWriteable() {
        // boolean writealbe = false;
        // long start = System.currentTimeMillis();
        // if (TextUtils.equals(Environment.MEDIA_MOUNTED,
        // Environment.getExternalStorageState())) {
        // File esd = Environment.getExternalStorageDirectory();
        // if (esd.exists() && esd.canWrite()) {
        // File file = new File(esd,
        // ".696E5309-E4A7-27C0-A787-0B2CEBF1F1AB");
        // if (file.exists()) {
        // writealbe = true;
        // } else {
        // try {
        // writealbe = file.createNewFile();
        // } catch (IOException e) {
        // if (DEBUG) {
        // Log.w(TAG,
        // "isExternalStorageWriteable() can't create test file.");
        // }
        // }
        // }
        // }
        // }
        // long end = System.currentTimeMillis();
        // if (DEBUG) {
        // Log.i(TAG, "Utility.isExternalStorageWriteable(" + writealbe
        // + ") cost " + (end - start) + "ms.");
        // }
        // return writealbe;
        return PathUtils.isExternalStorageWritable();
    }

    /**
     * 检测component是否可用
     * 
     * @param ctx context
     * @param className class name
     * @return 该组件是否可用
     */
    @PluginAccessable(methodName = "isComponentEnable", paramClasses = { Context.class, String.class })
    public static boolean isComponentEnable(Context ctx, String className) {
        PackageManager pm = ctx.getPackageManager();
        ComponentName cn = new ComponentName(ctx.getPackageName(), className);
        int ret = pm.getComponentEnabledSetting(cn);
        if (ret == PackageManager.COMPONENT_ENABLED_STATE_ENABLED
                || ret == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT) {
            return true;
        }
        return false;
    }

    /**
     * 在url后增加参数, 如果已有该参数，忽略不加.
     * 
     * @param url 在url附加参数
     * @param key key
     * @param value value
     * @return Url.
     * @deprecated 请使用 lib-util 下的 {@link UrlUtil#addParam(String, String, String)}
     */
    @Deprecated
    @PluginAccessable(methodName = "addParam", paramClasses = { String.class, String.class, String.class })
    public static String addParam(String url, String key, String value) {
        return UrlUtil.addParam(url, key, value);
    }
    
    /**
     * 删掉url中的指定参数
     * 
     * @param url url
     * @param dParams 需删除的参数列表
     * @return 去掉指定参数后的url
     * @deprecated 请使用 lib-util 下的 {@link UrlUtil#deleteParam(String, Set)}
     */
    @Deprecated
    @PluginAccessable(methodName = "deleteParam", paramClasses = { String.class, Set.class })
    public static String deleteParam(String url, Set<String> dParams) {
        return UrlUtil.deleteParam(url, dParams);
    }

    /**
     * 截断url所有的参数 （以？为准）
     * 
     * @param url 原始url
     * @return 截断后的url
     * @deprecated 请使用 lib-util 下的 {@link UrlUtil#delAllParamsFromUrl(String)}
     */
    @Deprecated
    @PluginAccessable(methodName = "delAllParamsFromUrl", paramClasses = { String.class })
    public static String delAllParamsFromUrl(String url) {
        return UrlUtil.delAllParamsFromUrl(url);
    }

    /**
     * 修改某个路径的读写权限
     * 
     * @param path 绝对路径
     * @param mode 读写权限
     */
    @PluginAccessable(methodName = "chmod", paramClasses = { String.class, String.class })
    public static void chmod(String path, String mode) {
        try {
            Runtime.getRuntime().exec("chmod " + mode + " " + path);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 保持数据到文件
     * 
     * @param file 文件路径
     * @param data 数据
     */
    @PluginAccessable(methodName = "saveDataToFile", paramClasses = { String.class, String.class })
    public static void saveDataToFile(String file, String data) {
        if (file == null || data == null) {
            return;
        }
        FileOutputStream out = null;
        try {
            File f = new File(file);
            out = new FileOutputStream(f);
            out.write(data.getBytes());
            out.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * 判断该url是否属于baidu域
     * 
     * @param url 地址
     * @return 属于返回true,不属于返回false
     */
    @PluginAccessable(methodName = "isPartofBaidu", paramClasses = { String.class })
    public static boolean isPartofBaidu(String url) {
        if (!TextUtils.isEmpty(url)) {
            WebAddress address = new WebAddress(url);
            if (address.mHost.endsWith(".baidu.com")) {
                return true;
            }
        }
        return false;
    }

    /**
     * 
     * @param connected 是否有网络
     * @param type 网络类型
     * @return json串
     */
    @PluginAccessable(methodName = "joinNetworkJson", paramClasses = { int.class, String.class })
    public static String joinNetworkJson(int connected, String type) {
        String format1 = "{\"connected\":\"%d\"";
        String format2 = ",\"network\":\"%s\"}";
        if (connected == 0) {
            return (String.format(format1, connected) + "}");
        } else {
            if (type == null) {
                return null;
            }
            return (String.format(format1, connected) + String.format(format2, type));
        }
    }

    /**
     * 弹出刷新失败信息
     * 
     * @param context 上下文
     * @param str 失败信息
     */
    @PluginAccessable(methodName = "showToast", paramClasses = { Context.class, String.class })
    public static void showToast(Context context, String str) {
        if ((context != null) && (str != null)) {
            Toast.makeText(context, str, Toast.LENGTH_SHORT).show();
        }
    }

    /**
     * 返回系统的Model
     * @return 系统的Model
     */
    @PluginAccessable(methodName = "getDeviceModelName", paramClasses = { })
    public static String getDeviceModelName() {
        return Build.MODEL;
    }

    /**
     * 返回系统的Version
     * @return 系统的Version
     */
    @PluginAccessable(methodName = "getSysVersion", paramClasses = { })
    public static String getSysVersion() {
        return Build.VERSION.RELEASE;
    }

    /**
     * 返回框的VersionCode
     * 
     * @param context 内部直接使用框的Context，传入的参数值会被忽略
     * @return string 框的VersionCode
     */
    @PluginAccessable(methodName = "getVersionCode", paramClasses = { Context.class })
    public static String getVersionCode(Context context) {
        // 此处直接使用框的Context是为了防止插件传入自身Context时导致的问题
        Context innerContext = SearchBox.getAppContext();
        if (TextUtils.isEmpty(sBoxVersionCode)) {
            try {
                PackageInfo info =
                        innerContext.getPackageManager().getPackageInfo(innerContext.getPackageName(), 0);
                sBoxVersionCode = info.versionCode + "";
            } catch (NameNotFoundException e) {
                if (DEBUG) {
                    e.printStackTrace();
                }
            }
        }
        return sBoxVersionCode;
    }

    /**
     * 返回框的VersionName
     *
     * @param context 内部直接使用框的Context，传入的参数值会被忽略
     * @return string 框的VersionCode
     */
    @PluginAccessable(methodName = "getVersionName", paramClasses = { Context.class })
    public static String getVersionName(Context context) {
        // 此处直接使用框的Context是为了防止插件传入自身Context时导致的问题
        Context innerContext = SearchBox.getAppContext();
        if (TextUtils.isEmpty(sBoxVersionName)) {
            try {
                PackageInfo info =
                        innerContext.getPackageManager().getPackageInfo(innerContext.getPackageName(), 0);
                sBoxVersionName = info.versionName + "";
            } catch (NameNotFoundException e) {
                if (DEBUG) {
                    e.printStackTrace();
                }
            }
        }
        if (DEBUG) {
            Log.d(TAG, "getVersionName:" + sBoxVersionName);
        }
        return sBoxVersionName;
    }

    /**
     * 保存图片后要进行Media扫描
     * 
     * @author liuxinjian
     * @since 2013-1-15
     */
    public static class ShareMediaScannerConnectionClient implements MediaScannerConnectionClient {
        /** MediaScanner服务的链接Connection */
        private MediaScannerConnection mConnection;

        /** 保存的图片的绝对路径 */
        private String mFile;

        /**
         * 设置MediaScanner服务
         * 
         * @param connection MediaScanner服务的链接Connection
         * @param file 图片的绝对路径
         */
        public void setMediaScannerConnection(MediaScannerConnection connection, String file) {
            mConnection = connection;
            mFile = file;
        }

        @Override
        public void onMediaScannerConnected() {
            mConnection.scanFile(mFile, null);
            if (DEBUG) {
                Log.d(TAG, "onMediaScannerConnected() -> scanFile(" + mFile + ")");
            }
        }

        @Override
        public void onScanCompleted(String path, Uri uri) {
            if (DEBUG) {
                Log.d(TAG, "onScanCompleted() -> path=" + path + ", uri=" + uri);
            }

            mConnection.disconnect();
        }
    }

    /** 日期格式化对象 */
    private static SimpleDateFormat mDateFormat = null;

    /**
     * 将时间转换为格式化的字符串，时间格式如：7月31日 21:43
     * 
     * @param time 时间
     * @return 字符串
     */
    @PluginAccessable(methodName = "formatDateTime", paramClasses = { long.class })
    public static synchronized String formatDateTime(long time) {
        if (0 == time) {
            return "";
        }

        if (null == mDateFormat) {
            mDateFormat = new SimpleDateFormat("MM-dd HH:mm");
        }

        Date date = new Date(time);
        return mDateFormat.format(date);
    }

    // Added by LiHong 20130909 begin ============
    /**
     * DisplayMetrics 对象
     */
    private static DisplayMetrics sDisplayMetrics;

    /**
     * 返回显示宽度
     * 
     * @param context 内部使用框的Context，传入值被忽略
     * 
     * @return 宽度
     */
    @PluginAccessable(methodName = "getDisplayWidth", paramClasses = { Context.class })
    public static int getDisplayWidth(Context context) {
        // 使用框的Context，防止插件调用接口时传入自己的Context
        initDisplayMetrics(SearchBox.getAppContext());
        return sDisplayMetrics.widthPixels;
    }

    /**
     * 得到显示高度
     * 
     * @param context 内部使用框的Context，传入值被忽略
     * 
     * @return 高度
     */
    @PluginAccessable(methodName = "getDisplayHeight", paramClasses = { Context.class })
    public static int getDisplayHeight(Context context) {
        // 使用框的Context，防止插件调用接口时传入自己的Context
        initDisplayMetrics(SearchBox.getAppContext());
        return sDisplayMetrics.heightPixels;
    }

    /**
     * 得到显示密度
     * 
     * @param context 内部使用框的Context，传入值被忽略
     * 
     * @return 密度
     */
    @PluginAccessable(methodName = "getDensity", paramClasses = { Context.class })
    public static float getDensity(Context context) {
        // 使用框的Context，防止插件调用接口时传入自己的Context
        initDisplayMetrics(SearchBox.getAppContext());
        return sDisplayMetrics.density;
    }

    /**
     * 得到DPI
     * 
     * @param context 内部使用框的Context，传入值被忽略
     * 
     * @return DPI
     */
    @PluginAccessable(methodName = "getDensityDpi", paramClasses = { Context.class })
    public static int getDensityDpi(Context context) {
        // 使用框的Context，防止插件调用接口时传入自己的Context
        initDisplayMetrics(SearchBox.getAppContext());
        return sDisplayMetrics.densityDpi;
    }

    /**
     * 初始化DisplayMetrics
     * 
     * @param context Context
     */
    private static void initDisplayMetrics(Context context) {
        if (null == sDisplayMetrics) {
            Context appContext = SearchBox.getAppContext();
            if (null == appContext) {
                appContext = context;
            }
            sDisplayMetrics = appContext.getResources().getDisplayMetrics();
        }
    }

    /**
     * 缩放指定大小的bitmap
     * 
     * @param bitmap 源bitmap
     * @param dstWidth 目标宽度
     * @param dstHeight 目标高度
     * 
     * @return 缩放后的bitmap
     */
    @PluginAccessable(methodName = "getSizedBitmap", paramClasses = { Bitmap.class, int.class, int.class })
    public static Bitmap getSizedBitmap(Bitmap bitmap, int dstWidth, int dstHeight) {
        if (null != bitmap) {
            try {
                if (dstWidth > 0 && dstHeight > 0) {
                    Bitmap result = Bitmap.createScaledBitmap(bitmap, dstWidth, dstHeight, true);
                    return result;
                }
            } catch (OutOfMemoryError e) {
                e.printStackTrace();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return bitmap;
    }

    /**
     * 缩放指定大小的bitmap
     * 
     * @param bitmap 源bitmap
     * @param dstWidth 目标宽度
     * @param dstHeight 目标高度
     * @param keepRatio 保持宽高比
     * 
     * @return 缩放后的bitmap
     */
    @PluginAccessable(methodName = "getSizedBitmap",
            paramClasses = { Bitmap.class, int.class, int.class, boolean.class })
    public static Bitmap getSizedBitmap(Bitmap bitmap, int dstWidth, int dstHeight, boolean keepRatio) {
        if (null != bitmap) {
            try {
                if (dstWidth > 0 && dstHeight > 0) {
                    float srcWidth = bitmap.getWidth();
                    float srcHeight = bitmap.getHeight();
                    // Calculate the scale ratio on both axis x and y.
                    float scaleRatioX = dstWidth / srcWidth;
                    float scaleRatioY = dstHeight / srcHeight;
                    // Get the final scale which we need to apply to image to let it fit the clip region.
                    float scale = Math.min(scaleRatioX, scaleRatioY);

                    float newWidth = keepRatio ? scale * srcWidth : dstWidth;
                    float newHeight = keepRatio ? scale * srcHeight : dstHeight;

                    Bitmap result = Bitmap.createScaledBitmap(bitmap, (int) newWidth, (int) newHeight, true);
                    return result;
                }
            } catch (OutOfMemoryError e) {
                e.printStackTrace();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return bitmap;
    }

    // Added by LiHong 20130909 end ==============

    // ADD BY nifuchen 从BdExplorerView中移过来，各浏览模块均可使用，后续做视频模块时集中优化此流程
    /**
     * 是否是直接播放视频
     * 
     * @param url 视频地址
     * @param contentDisposition contentDisposition
     * @param mimetype 视频MimeType
     * @return 是否打开了视频
     */
    @PluginAccessable(methodName = "isPlayVideoDirectly", paramClasses = { String.class, String.class, String.class })
    public static boolean isPlayVideoDirectly(String url, String contentDisposition, String mimetype) {
        // 只打开视频文件，其它的让其下载
        if (mimetype != null && mimetype.startsWith("video/")) {
            if (contentDisposition == null || !contentDisposition.regionMatches(true, 0, "attachment", 0, 10)) { // SUPPRESS
                                                                                                                 // CHECKSTYLE
                return true;
            }
        }
        return false;
    }

    /**
     * 播放视频，如果没有安装播放内核，提示用户安装
     * 
     * @param context context
     * @param url 视频地址
     * @param contentDisposition contentDisposition
     * @param mimetype 视频MimeType
     * @param mWebPageTitle webview页面标题
     * @return 是否打开了视频
     */
    @PluginAccessable(methodName = "playVideoDirectly", paramClasses = { Context.class, String.class, String.class,
            String.class, String.class })
    public static boolean playVideoDirectly(Context context, String url, String contentDisposition, String mimetype,
            String mWebPageTitle) {
        return playVideoDirectly(context, url, contentDisposition, mimetype, mWebPageTitle, null, false);
    }

    /**
     * 播放视频，如果没有安装播放内核，提示用户安装
     * 
     * @param context context
     * @param url 视频地址
     * @param contentDisposition contentDisposition
     * @param mimetype 视频MimeType
     * @param webPageTitle webview页面标题
     * @param webPageUrl 当前的url
     * @param needActivityForResult 是否需要Activity返回结果
     * @return 是否打开了视频
     */
    @PluginAccessable(methodName = "playVideoDirectly", paramClasses = { Context.class, String.class, String.class,
            String.class, String.class, String.class, boolean.class })
    public static boolean playVideoDirectly(Context context, String url, String contentDisposition, String mimetype,
            String webPageTitle, String webPageUrl, boolean needActivityForResult) {
        // 已安装播放内核
        Intent intent = new Intent();
        intent.putExtra(VideoPlayUtil.SRC_URL_NAME, url);
        intent.putExtra(VideoPlayUtil.DEST_URL_NAME, url);
        intent.putExtra(VideoPlayUtil.VIDEO_TYPE_NAME, BdVideo.TYPE_NORMAL);
        intent.putExtra(VideoPlayUtil.KEY_PAGE_TITLE, webPageTitle);
        intent.putExtra(VideoPlayUtil.KEY_PAGE_URL, webPageUrl);
        if (!(context instanceof MainActivity)) {
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        }
        AbsVideoPlayer player =
                new VideoPlayerFactory(context).getVideoPlayer(IVideoPlayer.PlayerType.PLAYER_TYPE_DEFAULT,
                        new PluginVideoPlayInfo(null, null, url, webPageTitle, null, null, null,
                                VideoPlayHistoryItemInfo.SRC_TYPE_NORMAL));
        player.play();
        if (VideoPlayUtil.isAvailable(context)) {
            return true;
        }
        return false;
    }

    /**
     * 播放视频，如果没有安装播放内核，提示用户安装
     * 
     * @param context context
     * @param url 视频地址
     * @param contentDisposition contentDisposition
     * @param mimetype 视频MimeType
     * @param webPageTitle webview页面标题
     * @param webPageUrl 当前的url
     * @param needActivityForResult 是否需要Activity返回结果
     * @return 是否打开了视频
     */
    @PluginAccessable(methodName = "playLocalVideoDirectly", paramClasses = { Context.class, String.class,
            String.class, String.class, String.class, String.class, boolean.class })
    public static boolean playLocalVideoDirectly(Context context, String url, String contentDisposition,
            String mimetype, String webPageTitle, String webPageUrl, boolean needActivityForResult) {
        // 已安装播放内核
        Intent intent = new Intent();
        intent.putExtra(VideoPlayUtil.VIDEO_TYPE_NAME, BdVideo.TYPE_NORMAL);
        intent.putExtra(VideoPlayUtil.KEY_PAGE_TITLE, webPageTitle);
        intent.putExtra(VideoPlayUtil.KEY_LOCAL_URI, url);
        if (!(context instanceof MainActivity)) {
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        }
        AbsVideoPlayer player =
                new VideoPlayerFactory(context).getVideoPlayer(IVideoPlayer.PlayerType.PLAYER_TYPE_DEFAULT,
                        new PluginVideoPlayInfo(null, null, url, webPageTitle, null, null, null,
                                VideoPlayHistoryItemInfo.SRC_TYPE_NORMAL));
        player.play();
        if (VideoPlayUtil.isAvailable(context)) {
            return true;
        }
        return false;
    }

    // add end

    // added by xiedongwei 20131030 begin用于判断SD卡是否有要求大小剩余空间
    /**
     * @Description: 当前sd卡是否可用，且有足够的剩余存储空间
     * @param needSpace 所需要的空间大小(字节)
     * @return true ：当前sd卡可用
     */
    @PluginAccessable(methodName = "isSdcardAvailable", paramClasses = { long.class })
    public static boolean isSdcardAvailable(final long needSpace) {
        return Environment.getExternalStorageDirectory() != null
                && Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())
                && isEnoughSpace(Environment.getExternalStorageDirectory(), needSpace);
    }

    /**
     * @Description: 当前/data分区是否可用，且有足够的剩余存储空间
     * @param needSpace 所需要的空间大小(字节)
     * @return true ：当前data分区可用
     */
    @PluginAccessable(methodName = "isDataAvailable", paramClasses = { long.class })
    public static boolean isDataAvailable(final long needSpace) {
        return Environment.getDataDirectory() != null && isEnoughSpace(Environment.getDataDirectory(), needSpace);
    }

    /**
     * @Description: 判断所传的目录是否有足够的空间可用
     * @param path 需要判断的目录
     * @param size 需要的大小
     * @return boolean 有足够的空间则为true，否则为false
     */
    @PluginAccessable(methodName = "isEnoughSpace", paramClasses = { File.class, long.class })
    public static boolean isEnoughSpace(File path, final long size) {
        StatFs sf = new StatFs(path.getPath());
        long blockSize = sf.getBlockSize();
        long freeBolcks = sf.getAvailableBlocks();

        if (DEBUG) {
            Log.d(TAG, "Available size:" + (blockSize * freeBolcks));
        }
        if ((blockSize * freeBolcks) > size) {
            return true;
        }
        return false;
    }

    // added by xiedongwei 20131030 end

    // added by fjx 解决下载的文件后缀经常为bin的问题，代码copy自系统，进行了小的优化 20131112
    /** Regex used to parse content-disposition headers */
    private static final Pattern CONTENT_DISPOSITION_PATTERN = Pattern.compile(
            "attachment;\\s*filename\\s*=\\s*(\"?)([^\"]*)\\1\\s*$", Pattern.CASE_INSENSITIVE);

    /**
     * Parse the Content-Disposition HTTP Header. The format of the header is defined here:
     * http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html This header provides a filename for content that is going
     * to be downloaded to the file system. We only support the attachment type. Note that RFC 2616 specifies the
     * filename value must be double-quoted. Unfortunately some servers do not quote the value so to maintain consistent
     * behaviour with other browsers, we allow unquoted values too.
     * 
     * @param contentDisposition String
     * @return 获取文件名
     */
    static String parseContentDisposition(String contentDisposition) {
        try {
            Matcher m = CONTENT_DISPOSITION_PATTERN.matcher(contentDisposition);
            if (m.find()) {
                return m.group(2);
            }
        } catch (IllegalStateException ex) {
            ex.printStackTrace();
            // This function is defined as returning null when it can't parse the header
        }
        return null;
    }

    /**
     * 从url从抽取文件名
     * 
     * @param url String
     * @return /xxxx.mp4?yyy, 返回xxxx.mp4
     */
    @PluginAccessable(methodName = "getFileNameFromUrl", paramClasses = { String.class })
    public static String getFileNameFromUrl(String url) {
        String filename = null;
        String decodedUrl = Uri.decode(url);
        if (decodedUrl != null) {
            int queryIndex = decodedUrl.indexOf('?');
            // If there is a query string strip it, same as desktop browsers
            if (queryIndex > 0) {
                decodedUrl = decodedUrl.substring(0, queryIndex);
            }
            if (!decodedUrl.endsWith("/")) {
                int index = decodedUrl.lastIndexOf('/') + 1;
                if (index > 0) {
                    filename = decodedUrl.substring(index);
                }
            }
        }

        return filename;
    }

    /**
     * Guesses canonical filename that a download would have, using the URL and contentDisposition. File extension, if
     * not defined, is added based on the mimetype
     * 
     * @param url Url to the content
     * @param contentDisposition Content-Disposition HTTP header or null
     * @param mimeType Mime-type of the content or null
     * 
     * @return suggested filename
     */
    @PluginAccessable(methodName = "guessFileName", paramClasses = { String.class, String.class, String.class })
    public static String guessFileName(String url, String contentDisposition, String mimeType) {
        String filename = null;
        String extension = null;

        // If we couldn't do anything with the hint, move toward the content disposition
        if (filename == null && contentDisposition != null) {
            filename = parseContentDisposition(contentDisposition);

            if (filename != null) {
                int index = filename.lastIndexOf('/') + 1;
                if (index > 0) {
                    filename = filename.substring(index);
                }
            }
        }

        // If all the other http-related approaches failed, use the plain uri
        if (TextUtils.isEmpty(filename)) {
            filename = getFileNameFromUrl(url);

        }
        Log.e("zhaodsh", "guessFileName: url: " + url + " filename: " + filename);
        // Finally, if couldn't get filename from URI, get a generic filename
        if (TextUtils.isEmpty(filename)) {
            filename = "downloadfile";
        }

        // Split filename between base and extension
        // Add an extension if filename does not have one
        int dotIndex = filename.indexOf('.');
        if (dotIndex < 0) {
            if (mimeType != null) {
                extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
                if (extension != null) {
                    extension = "." + extension;
                }
            }
            if (extension == null) {
                if (mimeType != null && mimeType.toLowerCase().startsWith("text/")) {
                    if (mimeType.equalsIgnoreCase("text/html")) {
                        extension = ".html";
                    } else {
                        extension = ".txt";
                    }
                } else {
                    // modify by fjx BEGIN
                    String ext = null;
                    String name = getFileNameFromUrl(url);
                    if (!TextUtils.isEmpty(name)) {
                        int lastDotIndex = name.lastIndexOf('.');
                        if (lastDotIndex != -1) {
                            ext = name.substring(lastDotIndex + 1);
                        }
                    }
                    if (!TextUtils.isEmpty(ext)) {
                        extension = "." + ext;
                    } else {
                        extension = ".bin";
                    }
                    // END
                }
            }
        } else {
            if (mimeType != null) {
                // Compare the last segment of the extension against the mime type.
                // If there's a mismatch, discard the entire extension.
                int lastDotIndex = filename.lastIndexOf('.');
                String typeFromExt =
                        MimeTypeMap.getSingleton().getMimeTypeFromExtension(filename.substring(lastDotIndex + 1));
                if (typeFromExt != null && !typeFromExt.equalsIgnoreCase(mimeType)) {
                    extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
                    if (extension != null) {
                        extension = "." + extension;
                    }
                }
            }
            if (extension == null) {
                extension = filename.substring(dotIndex);
            }
            filename = filename.substring(0, dotIndex);
        }

        // 控制一下文件名的长度
        if (filename != null) {
            int len = filename.length();
            final int MAX_FILE_NAME_LEN = 50;
            if (len > MAX_FILE_NAME_LEN) {
                filename = filename.substring(0, MAX_FILE_NAME_LEN);
            }
        }
        return filename + extension;
    }

    // added by fjx 20131112 end

    /**
     * 获取加密的渠道号
     * 
     * @param aChannel 渠道号
     * @return 加密的渠道号
     */
    @PluginAccessable(methodName = "getEncodedChannel", paramClasses = { String.class })
    public static String getEncodedChannel(String aChannel) {
        if (aChannel == null || aChannel.length() == 0) {
            return "";
        }

        String channel = aChannel.toUpperCase(Locale.US);

        char[] sarr = channel.toCharArray();
        StringBuilder result = new StringBuilder();

        // CHECKSTYLE:OFF
        for (char a : sarr) {
            int i = a;
            if (i > 64 && i < 91) {
                i += 12;
                i = i < 91 ? i : 65 + (i - 91);
            }

            if (i > 47 && i < 58) {
                i += 5;
                i = i < 58 ? i : 48 + (i - 58);
            }

            result.insert(0, (char) i);
        }
        // CHECKSTYLE:ON
        return result.toString();
    }

    /**
     * 获取packageName 关联的PacakgeInfo
     * 
     * @param context Context
     * @param packageName 应用包名
     * @return PackageInfo
     */
    @PluginAccessable(methodName = "getPacakgeInfo", paramClasses = { Context.class, String.class })
    public static PackageInfo getPacakgeInfo(Context context, String packageName) {
        PackageInfo pi;
        try {
            pi = context.getPackageManager().getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
            return pi;
        } catch (NameNotFoundException e) {
            if (DEBUG) {
                Log.w(TAG, e.getMessage());
            }
            return null;
        }
    }

    /**
     * 将字符数据写入到缓存中
     * 
     * @param data 数据
     * @param file 缓存文件
     * @return true成功，false失败
     */
    @PluginAccessable(methodName = "saveStringToCacheFile", paramClasses = { byte[].class, File.class })
    public static boolean saveStringToCacheFile(byte[] data, File file) {
        if (null == data) {
            return false;
        }

        FileOutputStream os = null;
        ByteArrayInputStream is = null;
        boolean succeed = false;

        try {
            is = new ByteArrayInputStream(data);
            os = new FileOutputStream(file);
            FileUtils.copyStream(is, os);
            succeed = true;
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            Utility.closeSafely(is);
            Utility.closeSafely(os);
        }

        return succeed;
    }

    /************** command針對之前版本的端能力,所以保留相應接口，command的实现移至SearchBoxCommandParser.java中 ****************/
    /**
     * Indicates whether the specified action can be used as an intent. This method queries the package manager for
     * installed packages that can respond to an intent with the specified action. If no suitable package is found, this
     * method returns false.
     * 
     * @param context The application's environment.
     * @param intent The Intent action to check for availability.
     * 
     * @return True if an Intent with the specified action can be sent and responded to, false otherwise.
     */
    @PluginAccessable(methodName = "isIntentAvailable", paramClasses = { Context.class, Intent.class })
    public static boolean isIntentAvailable(Context context, Intent intent) {
        if (intent == null) {
            return false;
        }

        final PackageManager packageManager = context.getPackageManager();
        List<ResolveInfo> list = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);

        return list.size() > 0;
    }

    /************** command針對之前版本的端能力,所以保留相應接口，command的实现移至SearchBoxCommandParser.java中 ****************/

    /**
     * 文案对应的command是否可用，command格式： { "mode": 0, "intent":
     * "intent:#Intent;action=com.baidu.searchbox.action.POETIZE;end", "class":
     * "com.baidu.searchbox.FetchPictureActivity", "min_v": "16783360" }
     * 
     * @param context context
     * @param command command
     * @return 是否可用
     */
    @PluginAccessable(methodName = "isCommandAvaliable", paramClasses = { Context.class, String.class })
    public static boolean isCommandAvaliable(Context context, String command) {
        JSONObject jsonObj;
        try {
            jsonObj = new JSONObject(command);
        } catch (JSONException e) {
            return false;
        }
        return CommandUtils.isCommandAvaliable(context, jsonObj);
    }

    /**
     * 解析文案对应的command，command格式如接口isCommandAvaliable 原有以String参数Command解析的接口，协议中，command中为object
     * 
     * @param context context
     * @param command command JsonString
     * @return 解析后的intent
     */
    @PluginAccessable(methodName = "parseCommand", paramClasses = { Context.class, String.class })
    public static Intent parseCommand(Context context, String command) {
        return parseCommand(context, command, Intent.URI_INTENT_SCHEME);
    }

    /**
     * 解析文案对应的command，command格式如接口isCommandAvaliable 原有以String参数Command解析的接口，协议中，command中为object
     * 
     * @param context context
     * @param command command JsonString
     *            <p>
     *            从6.1版本开始支持JsonArray
     * @param flag intent生成的标示
     * @return 解析后的intent
     */
    @PluginAccessable(methodName = "parseCommand", paramClasses = { Context.class, String.class, int.class })
    public static Intent parseCommand(Context context, String command, int flag) {
        return CommandUtils.parseCommand(context, command, flag);
    }

    /**
     * 解析文案对应的command，command格式如接口isCommandAvaliable
     * 
     * @param context context
     * @param command command JsonObject
     * @param flag 转化成intent的标示
     * @return 解析后的intent
     */
    @PluginAccessable(methodName = "parseCommand", paramClasses = { Context.class, JSONObject.class, int.class })
    public static Intent parseCommand(Context context, JSONObject command, int flag) {
        return CommandUtils.parseCommand(context, command, flag);
    }

    /**
     * 解析文案对应的command，command格式如接口isCommandAvaliable
     * 
     * @param context context
     * @param command command JsonObject
     * @return 解析后的intent
     */
    @PluginAccessable(methodName = "parseCommand", paramClasses = { Context.class, JSONObject.class })
    public static Intent parseCommand(Context context, JSONObject command) {
        return parseCommand(context, command, Intent.URI_INTENT_SCHEME);
    }

    /**
     * UI线程中调用,启动command
     * 
     * @param activity activity
     * @param command command，格式如isCommandAvaliable接口
     * @return 是否执行command成功,true：成功，false:失败
     */
    @PluginAccessable(methodName = "invokeCommand", paramClasses = { Context.class, String.class })
    public static boolean invokeCommand(Context activity, String command) {
        return CommandUtils.invokeCommand(activity, command);
    }

    /**
     * UI线程中调用,启动command
     * 
     * @param activity activity
     * @param command command，格式如isCommandAvaliable接口
     * @return 是否执行command成功,true：成功，false:失败
     */
    @PluginAccessable(methodName = "invokeCommand", paramClasses = { Context.class, JSONObject.class })
    public static boolean invokeCommand(Context activity, JSONObject command) {
        return CommandUtils.invokeCommand(activity, command, null);
    }

    /**
     * 创建command
     * 
     * @param mode command的mode
     * @param i Intent
     * @param minVersion 最小版本号
     * @param className className
     * @param url url
     * @param append append 添加公共参数
     * @param browserType 浏览框架类型
     * @param appId 轻应用appid
     * 
     * @return Command
     */
    @PluginAccessable(methodName = "createCommand", paramClasses = { String.class, Intent.class, String.class,
            String.class, String.class, boolean.class, String.class, String.class })
    public static String createCommand(String mode, Intent i, String minVersion, String className, String url,
            boolean append, String browserType, String appId) {
        return CommandUtils.createCommand(mode, i, minVersion, className, url, append, browserType, appId);
    }

    /************** command針對之前版本的端能力,所以保留相應接口，command的实现移至SearchBoxCommandParser.java中 ****************/

    /**
     * 将字符串进行私有gzip
     * 
     * @param data data
     * @return private gzipbyte[]
     */
    @PluginAccessable(methodName = "getPrivateGZIP", paramClasses = { String.class })
    public static byte[] getPrivateGZIP(String data) {
        if (data == null || data.length() == 0) {
            return null;
        }
        byte[] value = data.getBytes();
        byte[] gzipvalue = GZIP.gZip(value);
        // 替换前两个字节的魔法数字为757B(十六进制)
        gzipvalue[0] = GZIP_HEAD_1;
        gzipvalue[1] = GZIP_HEAD_2;
        return gzipvalue;
    }

    /**
     * 生成HTTP Post数据,增加使用魔法数字为757B
     * 
     * @param postParams 请求输入参数
     * @return HttpEntity
     */
    @PluginAccessable(methodName = "getPostDataReplaceBy757B", paramClasses = { String.class })
    public static HttpEntity getPostDataReplaceBy757B(String postParams) {
        if (TextUtils.isEmpty(postParams)) {
            return null;
        }
        byte[] compressBuffer = GZIP.gZip(postParams.getBytes());
        if (compressBuffer != null) {
            // 替换前两个字节的魔法数字为757B(十六进制)
            compressBuffer[0] = GZIP_HEAD_1;
            compressBuffer[1] = GZIP_HEAD_2;
            ByteArrayEntity entity = new ByteArrayEntity(compressBuffer);
            entity.setContentType("application/octet-stream");
            return entity;
        }
        return null;
    }

    /**
     * 点亮屏幕
     * 
     * @param context 获取到系统service
     * @param time 点亮的时间
     */
    @PluginAccessable(methodName = "acquireWakeLock", paramClasses = { Context.class, long.class })
    public static void acquireWakeLock(Context context, long time) {
        PowerManager pm = (PowerManager) context.getApplicationContext().getSystemService(Context.POWER_SERVICE);

        WakeLock wackLock =
                pm.newWakeLock(PowerManager.FULL_WAKE_LOCK | PowerManager.ACQUIRE_CAUSES_WAKEUP
                        | PowerManager.ON_AFTER_RELEASE, "");
        if (!pm.isScreenOn()) {
            wackLock.acquire(time);
        }
    }

    /**
     * 字符串中是否全是全格
     * 
     * @param s string
     * @return 是否全是全格
     */
    @PluginAccessable(methodName = "isAllSpace", paramClasses = { String.class })
    public static boolean isAllSpace(String s) {
        if (TextUtils.isEmpty(s)) {
            return false;
        }
        if (TextUtils.getTrimmedLength(s) == 0) {
            return true;
        }
        return false;
    }

    /**
     * 获取TextView对象的ShadowColor
     * 
     * @param textView textView
     * @return ShadowColor
     */
    @SuppressLint("NewApi")
    @PluginAccessable(methodName = "getShadowColor", paramClasses = { TextView.class })
    public static int getShadowColor(TextView textView) {
        if (APIUtils.hasJellyBean()) {
            return textView.getShadowColor();
        } else {
            Object property = getField(Paint.class, textView.getPaint(), "shadowColor");
            return null == property ? 0 : (Integer) property;
        }
    }

    /**
     * 获取TextView对象的ShadowDx
     * 
     * @param textView textView
     * @return ShadowDx
     */
    @SuppressLint("NewApi")
    @PluginAccessable(methodName = "getShadowDx", paramClasses = { TextView.class })
    public static float getShadowDx(TextView textView) {
        if (APIUtils.hasJellyBean()) {
            return textView.getShadowDx();
        } else {
            Object property = getField(TextView.class, textView, "mShadowDx");
            return null == property ? 0 : (Float) property;
        }
    }

    /**
     * 获取TextView对象的ShadowDy
     * 
     * @param textView textView
     * @return ShadowDy
     */
    @SuppressLint("NewApi")
    @PluginAccessable(methodName = "getShadowDy", paramClasses = { TextView.class })
    public static float getShadowDy(TextView textView) {
        if (APIUtils.hasJellyBean()) {
            return textView.getShadowDy();
        } else {
            Object property = getField(TextView.class, textView, "mShadowDy");
            return null == property ? 0 : (Float) property;
        }
    }

    /**
     * 获取TextView对象的ShadowRadius
     * 
     * @param textView textView
     * @return ShadowRadius
     */
    @SuppressLint("NewApi")
    @PluginAccessable(methodName = "getShadowRadius", paramClasses = { TextView.class })
    public static float getShadowRadius(TextView textView) {
        if (APIUtils.hasJellyBean()) {
            return textView.getShadowRadius();
        } else {
            Object property = getField(TextView.class, textView, "mShadowRadius");
            return null == property ? 0 : (Float) property;
        }
    }

    /**
     * 获取TextView对象的行间距Muti值
     * 
     * @param textView textView
     * @return ShadowRadius
     */
    @SuppressLint("NewApi")
    @PluginAccessable(methodName = "getTextViewSpacingMult", paramClasses = { TextView.class })
    public static float getTextViewSpacingMult(TextView textView) {
        if (APIUtils.hasJellyBean()) {
            return textView.getLineSpacingMultiplier();
        } else {
            Object property = getField(TextView.class, textView, "mSpacingMult");
            return null == property ? 0 : Float.valueOf(String.valueOf(property));
        }
    }

    /**
     * 反射获取对象的成员变量
     * 
     * @param target target class
     * @param owner owner
     * @param filedName filedName
     * @return field value
     */
    private static Object getField(Class<?> target, Object owner, String filedName) {
        Object property = null;
        try {
            Field field = target.getDeclaredField(filedName);
            if (!field.isAccessible()) {
                field.setAccessible(true);
            }
            property = field.get(owner);
        } catch (Exception e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        }
        return property;
    }

    /**
     * 获取系统状态栏的高度
     * 
     * @param context Context
     * @return 高度
     */
    @PluginAccessable(methodName = "getStatusBarHeight", paramClasses = { Context.class })
    public static int getStatusBarHeight(Context context) {
        Class<?> c = null;
        Object obj = null;
        Field field = null;
        try {
            c = Class.forName("com.android.internal.R$dimen");
            if (c != null) {
                obj = c.newInstance();
                field = c.getField("status_bar_height");
                if (obj != null && field != null) {
                    Object o = field.get(obj);
                    if (o != null) {
                        int x = Integer.parseInt(o.toString());
                        return context.getResources().getDimensionPixelSize(x);
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return 0;
    }

    /**
     * 字符串转换为长整型
     * 
     * @param value 字符串数据
     * @return 数据，如果转换异常时，默认值为0
     */
    @PluginAccessable(methodName = "parseLong", paramClasses = { String.class })
    public static long parseLong(String value) {
        long val = 0;

        try {
            val = Long.parseLong(value);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return val;
    }

    /**
     * Runs the specified action on the UI thread. If the current thread is the UI thread, then the action is executed
     * immediately.If the current thread is not the UI thread, the action is posted to the event queue of the UI thread.
     * 
     * <p>
     * 该功能与{@link Activity#runOnUiThread(Runnable)}一样
     * </p>
     * 
     * @param action the action to run on the UI thread
     */
    @PluginAccessable(methodName = "runOnUiThread", paramClasses = { Runnable.class })
    public static void runOnUiThread(Runnable action) {
        if (Thread.currentThread() != Looper.getMainLooper().getThread()) {
            Handler handler = SearchBox.getMainHandler();
            handler.post(action);
        } else {
            action.run();
        }
    }

    /**
     * Runs the specified action on the UI thread. If the current thread is the UI thread, then the action is executed
     * immediately.If the current thread is not the UI thread, the action is posted to the event queue of the UI thread.
     * 
     * <p>
     * 该功能与{@link Activity#runOnUiThread(Runnable)}一样
     * </p>
     * 
     * @param action the action to run on the UI thread
     * @param delayMillis 延时
     */
    @PluginAccessable(methodName = "runOnUiThread", paramClasses = { Runnable.class, long.class })
    public static void runOnUiThread(Runnable action, long delayMillis) {
        if (delayMillis > 0) {
            Handler handler = SearchBox.getMainHandler();
            handler.postDelayed(action, delayMillis);
        } else {
            runOnUiThread(action);
        }
    }

    /**
     * 收起状态栏
     * 
     * @param context the context used to fetch status bar manager
     */
    @PluginAccessable(methodName = "collapseStatusBar", paramClasses = { Context.class })
    public static void collapseStatusBar(Context context) {
        try {
            Object statusBarManager = context.getSystemService("statusbar");
            Method collapse;
            if (!APIUtils.hasJellyBeanMR1()) {
                collapse = statusBarManager.getClass().getMethod("collapse");
            } else {
                collapse = statusBarManager.getClass().getMethod("collapsePanels");
            }
            collapse.invoke(statusBarManager);
        } catch (Exception e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 检查是否在通话状态
     * 
     * @param context Context
     * @return 是否在通话状态
     */
    @PluginAccessable(methodName = "isInCall", paramClasses = { Context.class })
    public static boolean isInCall(Context context) {
        TelephonyManager tm =
                (TelephonyManager) SearchBox.getAppContext().getSystemService(Context.TELEPHONY_SERVICE);

        if (tm == null) {
            return false;
        }

        int callState = tm.getCallState();

        if (DEBUG) {
            Log.d(TAG, "call state = " + callState);
        }

        if (callState != TelephonyManager.CALL_STATE_IDLE) {
            return true;
        }
        return false;
    }

    /**
     * 获取当前网络是否为慢速网络
     * 
     * @param context context上下文
     * @return 是否为慢速网络
     */
    @PluginAccessable(methodName = "isPre3GNetwork", paramClasses = { Context.class })
    public static boolean isPre3GNetwork(Context context) {
        ConnectManager cm = new ConnectManager(SearchBox.getAppContext());
        String type = cm.getNetType();
        if (NET_TYPE_WIFI.equalsIgnoreCase(type)) {
            return false;
        }
        int subType = cm.getSubType();
        boolean isSlow = false;
        switch (subType) {
            case TelephonyManager.NETWORK_TYPE_1xRTT:
            case TelephonyManager.NETWORK_TYPE_CDMA:
            case TelephonyManager.NETWORK_TYPE_EDGE:
            case TelephonyManager.NETWORK_TYPE_GPRS:
            case TelephonyManager.NETWORK_TYPE_IDEN:
                isSlow = true;
                break;
            default:
                break;
        }
        if (DEBUG) {
            Log.d(TAG, "subtype name:" + cm.getSubTypeName() + "  is 2G:" + isSlow);
        }
        return isSlow;
    }

    /**
     * 获取手机屏幕通知栏高度
     * 
     * @param activity 当前activity
     * @return > 0 success; <= 0 fail
     */
    @PluginAccessable(methodName = "getStatusHeight", paramClasses = { Activity.class })
    public static int getStatusHeight(Activity activity) {
        int statusHeight = 0;
        Rect localRect = new Rect();
        activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(localRect);
        if (localRect.top == statusHeight) {
            Class<?> localClass;
            try {
                localClass = Class.forName("com.android.internal.R$dimen");
                Object localObject = localClass.newInstance();
                int barHeight = Integer.parseInt(localClass.getField("status_bar_height").get(localObject).toString());
                statusHeight = activity.getResources().getDimensionPixelSize(barHeight);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (InstantiationException e) {
                e.printStackTrace();
            } catch (NumberFormatException e) {
                e.printStackTrace();
            } catch (IllegalArgumentException e) {
                e.printStackTrace();
            } catch (SecurityException e) {
                e.printStackTrace();
            } catch (NoSuchFieldException e) {
                e.printStackTrace();
            }
        } else {
            statusHeight = localRect.top;
        }
        return statusHeight;
    }

    /**
     * 将double类型转换成String，解决科学计数法的问题
     * 
     * @param d double
     * @return String
     */
    @PluginAccessable(methodName = "double2String", paramClasses = { double.class })
    public static String double2String(double d) {
        BigDecimal decimal = new BigDecimal(Double.toString(d));
        return decimal.toString();
    }

    /**
     * 为了外部统一调用框能力，封装统计接口。
     * 
     * @param key 统计项的key
     */
    @PluginAccessable(methodName = "addOnlyKeyUEStatisticCache", paramClasses = { String.class })
    public static void addOnlyKeyUEStatisticCache(String key) {
        StatisticProcessor.addOnlyKeyUEStatisticCache(SearchBox.getAppContext(), key);
    }

    /**
     * 为了外部统一调用框能力，封装统计接口。
     * 
     * @param key 统计项的key
     * @param value 统计项的value
     */
    @PluginAccessable(methodName = "addOnlyValueUEStatisticCache", paramClasses = { String.class, String.class })
    public static void addOnlyValueUEStatisticCache(String key, String value) {
        StatisticProcessor.addOnlyValueUEStatisticCache(SearchBox.getAppContext(), key, value);
    }

    /**
     * 为了外部统一调用框能力，封装统计接口。
     * 
     * @param key 统计项的key
     * @param values 统计项的values
     */
    @PluginAccessable(methodName = "addValueListUEStatisticCache", paramClasses = { String.class, List.class })
    public static void addValueListUEStatisticCache(String key, List<String> values) {
        if (DEBUG) {
            Log.d(TAG, "addValueListUEStatisticCache(String, List<String>)");
            Log.d(TAG, "key:" + key);
            if (values != null) {
                for (String value : values) {
                    Log.d(TAG, "value:" + value);
                }
            }
        }
        StatisticProcessor.addValueListUEStatisticCache(SearchBox.getAppContext(), key, values);
    }

    /**
     * 供第三方插件使用的统计接口
     * 
     * @param pCode 分配给插件的代码
     * @param detailId 每个统计项的id
     * @param values 统计项的values
     */
    @PluginAccessable(methodName = "addThirdPartyUserActionWithPCode", paramClasses = { String.class, String.class,
            List.class })
    public static void addThirdPartyUserActionWithPCode(String pCode, String detailId, List<String> values) {
        if (TextUtils.isEmpty(pCode) || TextUtils.isEmpty(detailId)) {
            return;
        }

        String key = pCode + detailId;
        addValueListUEStatisticCache(key, values);
    }

    /**
     * 在App切到后台之前,将程序内存中缓存数据写入文件.
     */
    @PluginAccessable(methodName = "writeStatisticDataBeforeAppInBackground", paramClasses = {})
    public static void writeStatisticDataBeforeAppInBackground() {
        StatisticProcessor.getInstance(SearchBox.getAppContext()).writeStatisticDataBeforeAppInBackground();
    }

    /**
     * 将URL转换成一个唯一的值，返回的字符串会带上后缀（如果URL中有的话）
     * 
     * @param url URL
     * @return 经过MD5过后的字符串
     */
    @PluginAccessable(methodName = "getHashedString", paramClasses = { String.class })
    public static String getHashedString(String url) {
        return getHashedString(url, true);
    }

    /**
     * 将URL转换成一个唯一的值，返回的字符串会带上后缀（如果URL中有的话）
     * 
     * @param url URL
     * @param appendSuffix 是否追加URL中截取的后缀
     * @return 经过MD5过后的字符串
     */
    @PluginAccessable(methodName = "getHashedString", paramClasses = { String.class, boolean.class })
    public static String getHashedString(String url, boolean appendSuffix) {
        if (url == null || url.endsWith("/")) {
            return null;
        }

        String suffix = appendSuffix ? getSuffix(url) : null;
        StringBuilder sb = null;

        try {
            MessageDigest digest = MessageDigest.getInstance("MD5");
            byte[] dstbytes = digest.digest(url.getBytes("UTF-8")); // GMaFroid uses UTF-16LE
            sb = new StringBuilder();
            for (int i = 0; i < dstbytes.length; i++) {
                sb.append(Integer.toHexString(dstbytes[i] & 0xff));// SUPPRESS CHECKSTYLE
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (null != sb && null != suffix) {
            return sb.toString() + "." + suffix;
        }

        return (null != sb) ? sb.toString() : null;
    }

    /**
     * 得到文件名的后缀
     * 
     * @param fileName 文件名
     * @return 后缀
     */
    private static String getSuffix(String fileName) {
        int dotPoint = fileName.lastIndexOf(".");
        int slPoint = fileName.lastIndexOf("/");
        if (dotPoint < slPoint) {
            return null;
        }

        if (dotPoint != -1) {
            return fileName.substring(dotPoint + 1);
        }

        return null;
    }

    /**
     * Copy data from a source stream to destFile. Return true if succeed, return false if failed.
     * 
     * @param inputStream source file inputstream
     * @param destFile destFile
     * 
     * @return success return true
     */
    @PluginAccessable(methodName = "copyToFile", paramClasses = { InputStream.class, File.class })
    public static boolean copyToFile(InputStream inputStream, File destFile) {
        try {
            if (destFile.exists()) {
                destFile.delete();
            }
            FileOutputStream out = new FileOutputStream(destFile);
            try {
                byte[] buffer = new byte[4096]; // SUPPRESS CHECKSTYLE
                int bytesRead;
                while ((bytesRead = inputStream.read(buffer)) >= 0) {
                    out.write(buffer, 0, bytesRead);
                }
            } finally {
                out.flush();
                try {
                    out.getFD().sync();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                out.close();
            }
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 获取调用者的方法名
     * 
     * @return 调用都的方法名
     */
    public static String getCallerMethodName() {
        StackTraceElement[] array = Thread.currentThread().getStackTrace();
        if (array != null && array.length > CALLER_INDEX) {
            return array[CALLER_INDEX].getClassName() + "." + array[CALLER_INDEX].getMethodName() + " "
                    + array[CALLER_INDEX].getLineNumber();
        }
        return "";
    }

    /**
     * 根据插件包名获取已安装的插件的信息，json格式字符串
     * <p>
     * { "packageName":"com.baidu.searchbox.plugindemo", "versionCode":1, "versionName":"1.0", "isEnable":true }
     * </p>
     * 
     * @param packageName 插件包名
     * @return 已安装的插件信息
     */
    @PluginAccessable(methodName = "getInstalledPluginInfo", paramClasses = { String.class })
    public static String getInstalledPluginInfo(String packageName) {
        JSONObject jObject = getInstalledPluginInfoJSONObject(packageName);
        if (jObject != null) {
            return jObject.toString();
        }
        return null;
    }

    /**
     * 根据插件包名获取已安装的插件的信息
     * 
     * @param packageName 插件包名
     * @return 已安装的插件信息
     * @see #getInstalledPluginInfo(String)
     */
    public static JSONObject getInstalledPluginInfoJSONObject(String packageName) {
        JSONObject jObject = new JSONObject();
        if (TextUtils.isEmpty(packageName)) {
            return jObject;
        }
        long versionCode = PluginInstallManager.getInstance(
                SearchBox.getAppContext()).getInstalledVersion(packageName);
        if (PluginCache.getInstance(packageName).isInstallBroken(SearchBox.getAppContext())) {
            versionCode = -1;
        }
        String versionName = null;
        boolean isEnable = false;
        if (versionCode >= 0) {
            MAPackageInfo realInfo =
                    MAPackageManager.getInstance(SearchBox.getAppContext()).getPackageInfo(packageName);
            if (realInfo != null && versionCode == realInfo.versionCode) {
                versionName = realInfo.versionName;
            }
            isEnable = true;
        }
        try {
            jObject.put("packageName", packageName);
            jObject.put("versionCode", versionCode);
            if (!TextUtils.isEmpty(versionName)) {
                jObject.put("versionName", versionName);
            }
            if (isEnable) {
                jObject.put("isEnable", isEnable);
            }
        } catch (JSONException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        }
        
        return jObject;
    }

    /**
     * 根据插件包名获取插件的包信息,可能为空
     * 
     * @param packageName 插件包名
     * @return jsonString {versionName=??, versionCode=??}
     */
    @Deprecated
    @PluginAccessable(methodName = "getPluginpPackageInfo", paramClasses = { String.class })
    public static JSONObject getPluginpPackageInfo(String packageName) {
        return getInstalledPluginInfoJSONObject(packageName);
    }

    /**
     * 判断是否是zip文件，zip文件前4个字节是：504B0304
     * 
     * @param srcfile 指定文件file，不能为空
     * @return true 是zip文件，false不是zip文件
     */
    public static boolean isZipFile(File srcfile) {
        if (!srcfile.exists()) {
            return false;
        }
        // 取出前4个字节进行判断
        byte[] filetype = new byte[4]; // SUPPRESS CHECKSTYLE
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(srcfile);
            fis.read(filetype);
            if ("504B0304".equalsIgnoreCase(toHexString(filetype, "", true))) {
                return true;
            }
            return false;
        } catch (Exception e) {
            if (DEBUG) {
                e.printStackTrace();
            }
            return false;
        } finally {
            closeSafely(fis);
        }
    }

    /**
     * 判断是否是Gzip文件，gzip文件前4个字节是：1F8B0800
     * 
     * @param srcfile 指定文件file，不能为空
     * @return true 是Gzip文件，false不是Gzip文件
     */
    public static boolean isGzipFile(String srcfile) {
        File file = new File(srcfile);
        if (!file.exists()) {
            return false;
        }
        // 取出前4个字节进行判断
        byte[] filetype = new byte[4]; // SUPPRESS CHECKSTYLE
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(file);
            fis.read(filetype);
            if ("1F8B0800".equalsIgnoreCase(toHexString(filetype, "", true))) {
                return true;
            }
        } catch (Exception e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        } finally {
            closeSafely(fis);
        }
        return false;
    }

    /**
     * 解压gzip文件
     * 
     * @param srcFileName 源file
     * @param outFileName 解压后的file
     * @return 解压是否成功
     */
    public static boolean unGzipFile(File srcFileName, File outFileName) {
        if (srcFileName == null) {
            return false;
        }
        FileInputStream fis = null;
        FileOutputStream fos = null;
        GZIPInputStream gzip = null;
        try {
            fis = new FileInputStream(srcFileName);
            gzip = new GZIPInputStream(fis);
            fos = new FileOutputStream(outFileName);
            byte[] buf = new byte[FILE_STREAM_BUFFER_SIZE];
            int num = -1;
            while ((num = gzip.read(buf, 0, buf.length)) != -1) {
                fos.write(buf, 0, num);
            }
            fos.flush();
            return true;
        } catch (Exception e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        } finally {
            Utility.closeSafely(fis);
            Utility.closeSafely(fos);
            Utility.closeSafely(gzip);
        }
        return false;
    }

    /**
     * 获取自身安装包的copy文件路径
     * 
     * @param context {@link Context}
     * @return 文件路径
     */
    public static String getPackageSourcePath(Context context) {
        PackageManager pm = context.getPackageManager();
        ApplicationInfo info = null;
        try {
            info = pm.getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
        } catch (NameNotFoundException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        }
        if (info != null) {
            return info.sourceDir;
        }
        return null;
    }

    /**
     * 根据URL得到图标的byte数据
     * 
     * @param url url
     * @return byte[];
     */
    public static byte[] fetchIcon(String url) {
        if (TextUtils.isEmpty(url)) {
            return null;
        }

        byte[] bytes = null;
        try {
            Context context = SearchBox.getAppContext();
            // 如果网络可用，才从网上下载图片
            if (Utility.isNetworkConnected(context)) {
                long start = 0;
                if (DEBUG) {
                    start = System.currentTimeMillis();
                }
                Bitmap bmp = ImageUtils.getBitmapFromNet(context, 1, url);
                if (null != bmp) {
                    final ByteArrayOutputStream os = new ByteArrayOutputStream();
                    // 将Bitmap压缩成PNG编码，质量为100%存储
                    try {
                        bmp.compress(Bitmap.CompressFormat.PNG, 100, os); // SUPPRESS CHECKSTYLE
                        bytes = os.toByteArray();
                    } finally {
                        closeSafely(os);
                    }
                }
                long end = 0;
                if (DEBUG) {
                    end = System.currentTimeMillis();
                }

                if (DEBUG) {
                    Log.i(TAG, "load image from network, url = " + url + "   time = " + (end - start) + " ms");
                }
            }
        } catch (Exception e) {
            if (DEBUG) {
                Log.i(TAG, "load image from network, exception = " + e.getMessage());
            }
        }
        return bytes;
    }

    /**
     * 从assets读取bmp图片的字节数组
     * 
     * @param context context
     * @param path path
     * @return 字节数组
     */
    public static byte[] loadAssetsBmp(Context context, String path) {
        AssetManager am = context.getAssets();
        InputStream is = null;
        try {
            is = am.open(path);
            return getByteFromInputStream(is);
        } catch (IOException e) {
            if (DEBUG) {
                Log.w(TAG, "loadAssetsBmp", e);
            }
        } finally {
            Utility.closeSafely(is);
        }

        return null;
    }

    /**
     * 将图片的字节数组转换为bmp
     * 
     * @param context context
     * @param bmpBytes 图片字节流数据
     * @return bitmap
     */
    public static Bitmap bytesToBitmap(Context context, byte[] bmpBytes) {
        Bitmap bitmap = null;
        try {
            if (null != bmpBytes && bmpBytes.length > 0) {
                bitmap = BitmapFactory.decodeByteArray(bmpBytes, 0, bmpBytes.length);
            }
        } catch (OutOfMemoryError e) {
            if (DEBUG) {
                Log.d(TAG, e.getMessage());
            }
        } catch (Exception e) {
            if (DEBUG) {
                Log.d(TAG, e.getMessage());
            }
        }

        return bitmap;
    }

    /**
     * 添加需要在退出时反加载的插件
     * 
     * @param packageName 插件名
     */
    @PluginAccessable(methodName = "needInvokeOnHostExit", paramClasses = { String.class })
    public static void needInvokeOnHostExit(String packageName) {
        PluginLoadManager.getInstance(SearchBox.getAppContext()).addNeedInvokeOnHostExitPlugin(packageName);
    }

    /**
     * 获取渠道号
     * 
     * @return 渠道号
     */
    @PluginAccessable(methodName = "getTn", paramClasses = {})
    public static String getTn() {
        return "baidu_official";
        // return BaiduIdentityManager.getInstance(SearchBox.getAppContext()).getTn();
    }

    /**
     * 启动微站
     * 
     * @param context context
     * @param configData configData
     * @param extrasFromIntent 用于向浏览框架传递扩展属性
     * @param src 来源
     */
    @PluginAccessable(methodName = "invokeXSearchContainer", paramClasses = { Context.class, String.class,
            String.class, Bundle.class })
    public static void invokeXSearchContainer(Context context, String configData, String src, Bundle extrasFromIntent) {
        invokeXSearchContainer(context, null, configData, src, extrasFromIntent);
    }

    /**
     * 启动微站
     * 
     * @param context context
     * @param pageId 微站id
     * @param configData configData
     * @param extrasFromIntent 用于向浏览框架传递扩展属性
     * @param src 来源
     */
    @PluginAccessable(methodName = "invokeXSearchContainer", paramClasses = { Context.class, String.class,
            String.class, String.class, Bundle.class })
    public static void invokeXSearchContainer(Context context, String pageId, String configData, String src,
            Bundle extrasFromIntent) {
        XSearchUtils.invokeXSearchContainer(context, pageId, src, extrasFromIntent);
    }

    /**
     * 播放视频
     * 
     * @param context Context
     * @param downloadUrl 下载url
     * @param originalUrl 原网页url
     */
    @PluginAccessable(methodName = "startPlayVideo", paramClasses = { Context.class, String.class, String.class })
    public static void startPlayVideo(Context context, String downloadUrl, String originalUrl) {
        Intent intent = new Intent();
        intent.putExtra(VideoPlayUtil.SRC_URL_NAME, downloadUrl != null ? downloadUrl : originalUrl);
        intent.putExtra(VideoPlayUtil.DEST_URL_NAME, downloadUrl != null ? downloadUrl : originalUrl);
        intent.putExtra(VideoPlayUtil.VIDEO_TYPE_NAME, BdVideo.TYPE_NORMAL);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        VideoPlayUtil.startPlay(context, intent, VideoPlayUtil.REMOTO_VIDEO);
    }

    /**
     * 对url增加 uid，ua，机型 等参数，对参数（UID和UT）已经增加utf-8编码。
     * 
     * @param context Context
     * @param url 要处理的url
     * @return 返回增加了 uid，ua，机型 等参数的url
     */
    @PluginAccessable(methodName = "processUrl", paramClasses = { Context.class, String.class })
    public static String processUrl(Context context, String url) {
        return BaiduIdentityManager.getInstance(SearchBox.getAppContext()).processUrl(url);
    }

    /**
     * 网页搜索的uid进行特殊处理，作为pu参数的子参数。key: cuid。
     *
     * @param url 要处理的url
     * @param withNetworkParam 是否要增加network参数。若为false,则处理过的url不包含network参数。若为true，则包含
     * @return 返回增加了 cuid，ua，机型 , 等参数的url
     */
    @PluginAccessable(methodName = "processWebSearchUrl", paramClasses = { String.class, boolean.class })
    public static String processWebSearchUrl(String url, boolean withNetworkParam) {
        return BaiduIdentityManager.getInstance(SearchBox.getAppContext()).processWebSearchUrl(url, withNetworkParam);
    }


    /**
     * 处理特殊的模式
     * 
     * @param context 运行环境上下文
     * @param uri 要处理的schema对应的uri
     * @return 是否处理了特殊的模式
     */
    @PluginAccessable(methodName = "handleSpecialScheme", paramClasses = { Context.class, String.class })
    public static boolean handleSpecialScheme(Context context, String uri) {
        try {
            if (BaseWebView.handleSpecialScheme(context, uri)) {
                return true;
            }
        } catch (ActivityNotStartedException e) {
            e.printStackTrace();
        }
        return handleResultText(context, uri);
    }

    /**
     * 处理结果文本
     * 
     * @param context 运行环境上下文
     * @param text 结果文本
     * @return 结果是否已处理
     */
    private static boolean handleResultText(Context context, String text) {
        // 2015-09-13 modified by hechaohua
        if (context == null || TextUtils.isEmpty(text)) {
            return false;
        }
        Activity activity = null;
        if (context instanceof MAActivity) {
            activity = ((MAActivity) context).getActivity();
        } else if (context instanceof Activity) {
            activity = (Activity) context;
        } else {
            return false;
        }

        // <Add by xulingzhi 处理二维码登录扫描结果协议
        if (activity != null) {
            // 识别结果是不是扫码登陆BEGIN
            Intent i = activity.getIntent();
            if (DEBUG) {
                Log.d(TAG, activity + ".getIntent() = " + i.toUri(0));
            }
            String caller = i.getStringExtra(CodeScannerCaller.KEY_FROM);
            boolean flag = PassSapiHelper.handleQrLoginResult(text, activity, caller);
            if (flag) {
                activityFinish(context);
                return true;
            }
            // 识别结果是不是扫码登陆END
            // 识别是不是调起个人主页 BEGIN
            flag = AccountUserInfoManager.handlerUserInfo(text, activity);            
            if (flag) {
                activityFinish(context);
                return flag;
            }
            // 识别是不是调起个人主页  END

            // 识别是否由钱包调起，且文本为URL begin
            flag = CodeScannerActivity.CodeScannerCaller.WALLET.equals(caller) && Utility.isUrl(text);
            if (flag && activity != null) {
                String url = AppConfig.getWalletWhiteListUrl();
                url = addParam(url, "url", URLEncoder.encode(text));
                url = addParam(url, "ua", BaiduWalletPluginManagerProxy.getInstance().getWalletUA(SearchBox
                        .getAppContext(),
                        WalletManager.getInstance(context).getWalletVersionCode()));
                WalletBrowserActivity.start(SearchBox.getAppContext(), url, "3345414", false);
                return flag;
            }
            // 识别是否由钱包调起，且文本为URL end

            // 识别结果是不是扫码支付BEGIN
            flag =
                    WalletManager.getInstance(activity.getApplicationContext()).handleQrResult(
                            activity.getApplicationContext(), text);
            if (flag) {
                if (activity != null) {
                    activityFinish(context);
                }

                // 调起扫码付
                WalletCommandHandler.accessWalletService(activity.getApplicationContext(),
                        WalletConstants.SERVICE_ID_O2OPARSE, text);
                // WalletManager.getInstance(activity.getActivity().getApplicationContext()).getBaiduWallet()
                // .accessWalletService(activity.getActivity().getApplicationContext(),
                // QAConfig.WALLET_QR_SERVICE_ID,
                // text);
                WalletQrListGrabber grabber = new WalletQrListGrabber(activity);
                grabber.grabData();
                return flag;
            }

            // 处理扫码进群逻辑-start   modify by xiatian05 2016年3月23日
            flag = GroupInfoManager.handlerGroupInfo(text, activity);
            if (flag) {
                if (activity != null) {
                    activityFinish(context);
                }
                return flag;
            }
            // 处理扫码进群逻辑-end


            // 识别结果是不是扫码支付END

            /**
             * added by zhangchengdong on 2015.09.14 若text是一个url，提前判断是否是调起扫码调起框能力（如生活+）的url 此处用来处理从直接扫码过来的case
             */
            if (SchemeUtility.handleUrlForScheme(activity, text, SchemeUtility.SCHEME_LAUNCH_BY_QR_CODE_SCAN)) {
                if (activity != null) {
                    activityFinish(context);
                }
                return true;
            }

            // 处理糯米协议文本
            if (SchemeUtility.handleUrlForBainuoScheme(activity, text)) {
                if (activity != null) {
                    activityFinish(context);
                }
                return true;
            }

            // 识别结果是不是网址BEGIN
            flag = Utility.isUrl(text);
            if (flag && activity != null) {

                Intent intent = new Intent(activity, MainActivity.class);
                intent.setAction(IntentConstants.ACTION_VIEW);
                intent.setData(Uri.parse(Utility.addSchemeIfNeed(text)));
                if (DEBUG) {
                    if (DebugFeturesTab.isOpenUrlWithLightSearch()) {
                        intent.setClass(activity, LightSearchActivity.class);
                    }
                }
                activity.startActivity(intent);

                return flag;
            }
            // 识别结果是不是网址END

            // 识别结果是不是一键上传(反馈)特型BEGIN
            if (TextUtils.equals(text, OnekeyUploadActivity.ONEKEY_UPLOAD_SCHEMA)) {
                Intent intent = new Intent(activity, OnekeyUploadActivity.class);
                activity.startActivity(intent);
                activityFinish(context);
                return true;
            }
            // 识别结果是不是一键上传(反馈)特型END

            if (DEBUG) {
                // 尝试执行command
                if (Utility.isCommandAvaliable(context, text)) {
                    Utility.invokeCommand(activity, text);
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * 结束activity，因为MAActivity结束与Activity的结束是不一样的
     * 
     * @param context 上下文
     */
    private static void activityFinish(Context context) {
        if (context == null) {
            return;
        }
        if (context instanceof MAActivity) {
            MAActivity activity = ((MAActivity) context);
            activity.finish();
        } else if (context instanceof Activity) {
            Activity activity = (Activity) context;
            activity.finish();
        }
    }

    /**
     * 统一的退出并且杀死应用接口
     * 
     * @param context context
     */
    public static void closeApplication(Context context) {
        if (OEMConfiguartion.getInstance(context).isQuitKillProcess()) {
            context.stopService(new Intent(context, DownloadService.class));
            NotificationManager mNotificationManager =
                    (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
            mNotificationManager.cancelAll();

            // 清空Activity栈
            BaseActivity.clearTask();
            android.os.Process.killProcess(android.os.Process.myPid());
        }
    }

    /**
     * 处理轻应用扫码结果文本
     * 
     * @param context 运行环境上下文
     * @param text 结果文本
     * @param successful 是否成功扫描
     */
    @PluginAccessable(methodName = "handleLightAppResultText", paramClasses = { Context.class, String.class,
            boolean.class })
    public static void handleLightAppResultText(Context context, String text, boolean successful) {
        WebappController.getInstance().handleResult(BdLightappConstants.JsAction.QRCODE, text, successful);
    }

    /**
     * 上报GMV参数值，参数为<br/>
     * { "vmgdb":"006101" }
     * 
     * @param json 参数
     * @return 是否开始上报
     */
    @PluginAccessable(methodName = "sendGMVLog", paramClasses = { String.class })
    public static boolean sendGMVLog(String json) {
        try {
            JSONObject jObject = new JSONObject(json);
            JSONArray jArray = jObject.names();
            Map<String, String> paramMap = new HashMap<String, String>();
            for (int i = 0; i < jArray.length(); i++) {
                String key = jArray.getString(i);
                if (TextUtils.isEmpty(key)) {
                    continue;
                }
                String value = jObject.getString(key);
                if (TextUtils.isEmpty(value)) {
                    value = "";
                }
                paramMap.put(key, value);
            }
            if (paramMap.size() > 0) {
                DomesticServiceManager.getInstance().sendGMVLog(paramMap);
                return true;
            }
        } catch (JSONException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        }
        return false;
    }

    /**
     * 获取登录账号的uid
     * 
     * @param context context
     * @return uid
     */
    public static String getAccountUid(Context context) {
        BoxAccountManager boxAccountManager = BoxAccountManagerFactory.getBoxAccountManager(context);
        if (boxAccountManager.isLogin()) {
            BoxAccount boxAccount = boxAccountManager.getBoxAccount();
            if (boxAccount != null) {
                return boxAccount.uid;
            }
        }
        return null;
    }

    /**
     * 返回手机的IMEI信息
     *
     * @return IMEI相关信息
     */
    @PluginAccessable(methodName = "getIMEI", paramClasses = { })
    public static String getIMEI() {
        Context context = SearchBox.getAppContext();
        try {
            TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            return tm.getDeviceId();
        } catch (Exception e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        }

        return null;
    }

    /**
     * 载入assets中文件
     * 
     * @param context context
     * @param path 文件路径
     * 
     * @return 文件中字符串
     */
    public static String loadAssetsFile(Context context, String path) {
        InputStream is = null;
        String configStr = null;
        try {
            AssetManager am = context.getAssets();
            is = am.open(path);
            if (null == is) {
                return null;
            }

            // 获取预置文件中的字符串
            configStr = Utility.streamToString(is);
        } catch (IOException e) {
            if (DEBUG) {
                Log.w(TAG, "loadPresetDatas", e);
            }
        } finally {
            Utility.closeSafely(is);
        }
        return configStr;
    }

    /**
     * 转化json To Map
     * 
     * @param strJson 传入的json string
     * @return <String, String>的map
     */
    public static HashMap<String, String> jsonStrToHashMap(String strJson) {
        try {
            JSONObject itemJson = new JSONObject(strJson);
            HashMap<String, String> data = new HashMap<String, String>();
            Iterator it = itemJson.keys();
            // 遍历jsonObject数据，添加到Map对象
            while (it.hasNext()) {
                String key = String.valueOf(it.next());
                Object value = itemJson.get(key);
                data.put(key, value.toString());
            }
            return data;
        } catch (JSONException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
            return null;
        }
    }

    /**
     * 检查是否具有某权限
     * 
     * @param permissionName 权限名
     * @return true 授权
     */
    public static boolean checkPermission(String permissionName) {
        PackageManager pm = SearchBox.getAppContext().getPackageManager();
        boolean permission =
                (PackageManager.PERMISSION_GRANTED == pm.checkPermission(permissionName, SearchBox.getPkgName()));
        return permission;

    }

    /**
     * 获取dns解析后ip <br>
     * 需要单开一个线程使用
     * 
     * @param domain 域名，不带host，传入值如m.baidu.com
     * @return dns解析后ip
     */
    public static String getDnsIp(String domain) {
        if (TextUtils.isEmpty(domain)) {
            return null;
        }

        String ip = null;
        try {
            InetAddress ia = InetAddress.getByName(domain);
            ip = ia.getHostAddress();
            if (DEBUG) {
                Log.d(TAG, "dns ip = " + ip);
            }
        } catch (UnknownHostException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        }
        return ip;
    }

    /**
     * 计算一个TextView的宽度
     * 
     * @param view textview
     * @return int 该textview的实际宽度
     */
    public static int getTextViewWidth(TextView view) {
        int width = 0;
        if (view == null) {
            return width;
        }
        Paint paint = new Paint();
        paint.setTextSize(view.getTextSize());
        if (!TextUtils.isEmpty(view.getText())) {
            width = (int) paint.measureText(view.getText().toString());
        }
        return width;
    }

    /**
     * 计算一个TextView的高度
     * 
     * @param view textview
     * @return 该textView的实际高度
     */
    public static int getTextViewHeight(TextView view) {
        int height = 0;
        if (null == view) {
            return height;
        }
        Paint paint = new Paint();
        paint.setTextSize(view.getTextSize());
        FontMetrics fm = paint.getFontMetrics();
        if (!TextUtils.isEmpty(view.getText())) {
            height = (int) (Math.ceil(fm.descent - fm.ascent) + 2);
        }
        return height;
    }

    /**
     * 传入url返回host，如果url不规范，返回null
     * 
     * @param str 原始url字符串
     * @return url host
     */
    public static String getUrlhost(String str) {
        try {
            URL url = new URL(str);
            return url.getHost();
        } catch (MalformedURLException e) {
            if (DEBUG) {
                Log.d(TAG, "Incorrect url: " + e.getMessage());
            }
            return null;
        }
    }

    /**
     * 获取图片的采样率 ，请参考https://developer.android.com/training/displaying-bitmaps/load -bitmap.html
     * 
     * @param options 包含outWidth和outHeight的option
     * @param srcWidth srcWidth
     * @param srcHeight srcHeight
     * @param reqWidth 显示图片的最大宽度
     * @param reqHeight 显示图片的最大高度
     * @return sampleSize
     */
    public static int calculateInSampleSize(int srcWidth, int srcHeight, int reqWidth, int reqHeight) {
        // Raw height and width of image
        final int height = srcHeight;
        final int width = srcWidth;
        int inSampleSize = 1;

        if (height > reqHeight || width > reqWidth) {

            final int halfHeight = height / 2;
            final int halfWidth = width / 2;

            // Calculate the largest inSampleSize value that is a power of 2 and
            // keeps both
            // height and width larger than the requested height and width.
            while ((halfHeight / inSampleSize) > reqHeight && (halfWidth / inSampleSize) > reqWidth) {
                inSampleSize *= 2;
            }
        }

        return inSampleSize;
    }

    /**
     * decode simplesize bitmap
     * 
     * @param bytes bytes
     * @param width width
     * @param height height
     * @return Bitmap bitmap
     */
    public static Bitmap decodeSimpleSizeBitmap(byte[] bytes, int width, int height) {
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options);
        int srcWidth = options.outWidth;
        int srcHeight = options.outHeight;
        options.inJustDecodeBounds = false;
        options.inSampleSize = Utility.calculateInSampleSize(srcWidth, srcHeight, width, height);
        return BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options);
    }

    /**
     * 检查颜色数据是否合法
     * 
     * @param color 颜色
     * @return 是否合法
     */
    public static boolean isColorValid(Object color) {
        if (color instanceof String) {
            String checkColor = String.valueOf(color);
            if (TextUtils.isEmpty(checkColor)) {
                return false;
            }
            return checkColor.startsWith("#")
                    && (checkColor.length() == NO_ALPHA_STANDARD || checkColor.length() == WITH_ALPHA_STANDARD);
        }
        if (color instanceof Integer) {
            return true;
        }
        return false;
    }

    /**
     * 将bitmap转为bytes[]
     * 
     * @param bm bitmap
     * @return bytes[]
     */
    public static byte[] Bitmap2Bytes(Bitmap bm) {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] ret = null;
        try {
            bm.compress(Bitmap.CompressFormat.PNG, 100, baos);
            ret = baos.toByteArray();
        } finally {
            closeSafely(baos);
        }
        return ret;
    }

    /**
     * 计算文本的总字数(英文字符算半字，其他均为全字)
     * 
     * @param text text
     * @return text length
     */
    public static int countWordsLength(String text) {
        float length = 0;
        if (TextUtils.isEmpty(text)) {
            return (int) length;
        }
        char[] chars = text.toCharArray();
        for (char ch : chars) {
            if (ch > 0 && ch < 127) { // SUPPRESS CHECKSTYLE
                length += 0.5; // SUPPRESS CHECKSTYLE
            } else {
                length++;
            }
        }
        return (int) length;
    }

    /**
     * 获取指定字数长度的最后一个字符在字符串中的位置<br/>
     * (英文字符算半字，其他均为全字)
     * 
     * @param text text
     * @param wordsLength 文字长度
     * @return position
     */
    public static int getCharPosWithWordsLength(String text, int wordsLength) {
        if (TextUtils.isEmpty(text) || (wordsLength == 0)) {
            return 0;
        }

        if (wordsLength >= text.length()) {
            return text.length();
        }

        float size = 0;
        int pos = 0;
        char[] chars = text.toCharArray();
        for (char ch : chars) {
            if (ch > 0 && ch < 127) { // SUPPRESS CHECKSTYLE
                size += 0.5; // SUPPRESS CHECKSTYLE
            } else {
                size++;
            }
            if (size > wordsLength) {
                break;
            }
            pos++;
        }

        return pos;
    }

    /**
     * 判断字符串中是否包含emoji表情
     * 
     * @param source source text
     * @return has emoji
     */
    public static boolean containsEmoji(String source) {
        if (TextUtils.isEmpty(source)) {
            return false;
        }

        Pattern pattern =
                Pattern.compile("[\ud83c\udc00-\ud83c\udfff]|[\ud83d\udc00-\ud83d\udfff]|[\u2600-\u27ff]",
                        Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(source);
        if (matcher.find()) {
            return true;
        }
        return false;
    }
    
    /**
     * 创建某一个View的截图，直接调用draw方法而不是使用drawing cache，避免某些特殊View（如WebView)无法正常截图的情况
     * 
     * @param view 要截图的View
     * @return 截图
     */
    public static Bitmap captureViewSnapshot(View view) {
        if (view != null && view.getWidth() > 0 && view.getHeight() > 0) {
            try {
                int width = view.getWidth();
                int height = view.getHeight();
                
                Bitmap capture = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                Canvas c = new Canvas(capture);
                int state = c.save();
                view.draw(c);
                c.restoreToCount(state);
                
                return capture;
            } catch (OutOfMemoryError e) {
                return null;
            } catch (Exception e) { 
                //因为在绘图过程中，可能产生空指针，也可能出现内存不足，故在此统一处理。
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * 代码中手动操作修改cookie，不支持bduss操作
     *
     * <p><b>Notice:</b>调用者需要保证调用前BWebkit已经被初始化，否则无法携带、写入cookie。</p>
     * <p><b>Notice:</b>如果业务需要处理Bduss cookie，调用setCookieWithBdussOperate。</p>
     *
     * @param url cookie的Url
     * @param cookieValue cookie的值
     * @param sync 是否需要cookie sync
     * @param funcName 调用的模块/功能名称
     */
    @PluginAccessable(methodName = "setCookieManualNoBdussOperate", paramClasses = { String.class, String.class,
            boolean.class, String.class })
    public static void setCookieManualNoBdussOperate(String url, String cookieValue, boolean sync, String funcName) {
        SearchBoxCookieUtils.setCookieManualNoBdussOperate(url, cookieValue, sync, funcName);
    }

    /**
     * 在简版搜索框架发起搜索
     *
     * @param query 要搜索的关键词(不可为空)
     * @param packageName 插件包名（不可为空）
     */
    @PluginAccessable(methodName = "launchSimpleSearch", paramClasses = { String.class, String.class })
    public static void launchSimpleSearch(String query, String packageName) {
        if (TextUtils.isEmpty(query) || TextUtils.isEmpty(packageName)) {
            return;
        }

        // 调起简版搜索框架
        SearchManager.launchSimpleSearch(SearchBox.getAppContext(), query,
                StatisticConstants.ENTRANCE_APP_TOUCH);
        // 添加ubc统计
        JSONObject obj = new JSONObject();
        try {
            obj.putOpt("packageName", packageName);
        } catch (JSONException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        }
        UBC.onEvent("19", obj.toString());
    }

    /**
     * 唤起二维码扫描，提供给插件使用
     *
     * @param type 类型值为，lightapp.device.QR_TYPE.BARCODE和lightapp.device.QR_TYPE.QRCODE
     * @param listener 扫描结果回调
     */
    @PluginAccessable(methodName = "startQRCodeInPlugin",
            paramClasses = { String.class, BarcodePluginManager.ResultListener.class})
    public static void startQRCodeInPlugin(String type, BarcodePluginManager.ResultListener listener) {
        if (!LightApp.Device.QR_TYPE_QRCODE.equals(type)
                && !LightApp.Device.QR_TYPE_BARCODE.equals(type)) {
            if (listener != null) {
                listener.onResult(false, "Error qrcode type: " + type);
            }
            return;
        }

        if (listener != null) {
            BarcodePluginManager.getInstance().addListener(listener);
        }
        Intent intent = new Intent(SearchBox.getAppContext(), PluginBarcodeActivity.class);
        intent.putExtra(PluginBarcodeActivity.QR_TYPE, type);
        startActivitySafely(SearchBox.getAppContext(), intent);
    }

    /**
     * 返回宿主的{@link PackageInfo}，可以传入相应的flags
     * @param flags
     * @return 若获取失败，则返回null
     */
    @PluginAccessable(methodName = "getHostPackageInfo", paramClasses = { int.class })
    public static PackageInfo getHostPackageInfo(int flags) {
        PackageManager pm = SearchBox.getAppContext().getPackageManager();
        if (pm == null) {
            return null;
        }
        try {
            return pm.getPackageInfo(SearchBox.getAppContext().getPackageName(), flags);
        } catch (NameNotFoundException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
        }
        return null;
    }

    /**
     * 调起一键反馈
     * @param from 反馈来源
     * {@link com.baidu.searchbox.feedback.FeedbackInfoManager.FEEDBACK_WALLET}
     * {@link com.baidu.searchbox.feedback.FeedbackInfoManager.FEEDBACK_NEWS}
     * {@link com.baidu.searchbox.feedback.FeedbackInfoManager.FEEDBACK_NOVELSETTING}
     *
     */
    @PluginAccessable(methodName = "startFeedback",
            paramClasses = { String.class })
    public static void startFeedback(String from) {
        FeedbackInfoManager.startFaqIntent(from);
    }

    /**
     * 获取当前网络类型
     * <br/>
     * no: not connected
     * wifi/2g/3g/4g: net type
     * unknown: unknown net type
     * <br/>
     * @return wifi/2g/3g/4g/unknown
     */
    public static String getNetworkClass() {
        // check permission?
        ConnectivityManager cm = (ConnectivityManager) SearchBox.getAppContext().getSystemService(
                Context.CONNECTIVITY_SERVICE);
        NetworkInfo info = cm.getActiveNetworkInfo();
        if(info==null || !info.isConnected())
            return "no"; //not connected
        if(info.getType() == ConnectivityManager.TYPE_WIFI)
            return "wifi";
        if(info.getType() == ConnectivityManager.TYPE_MOBILE){
            int networkType = info.getSubtype();
            switch (networkType) {
                case TelephonyManager.NETWORK_TYPE_GPRS:
                case TelephonyManager.NETWORK_TYPE_EDGE:
                case TelephonyManager.NETWORK_TYPE_CDMA:
                case TelephonyManager.NETWORK_TYPE_1xRTT:
                case TelephonyManager.NETWORK_TYPE_IDEN: //api<8 : replace by 11
                    return "2g";
                case TelephonyManager.NETWORK_TYPE_UMTS:
                case TelephonyManager.NETWORK_TYPE_EVDO_0:
                case TelephonyManager.NETWORK_TYPE_EVDO_A:
                case TelephonyManager.NETWORK_TYPE_HSDPA:
                case TelephonyManager.NETWORK_TYPE_HSUPA:
                case TelephonyManager.NETWORK_TYPE_HSPA:
                case TelephonyManager.NETWORK_TYPE_EVDO_B: //api<9 : replace by 14
                case TelephonyManager.NETWORK_TYPE_EHRPD:  //api<11 : replace by 12
                case TelephonyManager.NETWORK_TYPE_HSPAP:  //api<13 : replace by 15
                    return "3g";
                case TelephonyManager.NETWORK_TYPE_LTE:    //api<11 : replace by 13
                    return "4g";
                default:
                    return "unknown";
            }
        }
        return "unknown";
    }
	
	/**
     * 线性转换 (Gradient = input + (output - input) / step * N)
     * @param input 起始值
     * @param output 结束值
     * @param cur 当前段数
     * @param step 拆分的段数
     */
    public static int getLinearGradientResult(int input, int output, int cur, int step) {
        int result = input + (output - input) / step * cur;
        return result;
    }

    /**
     * 生成json字符串
     *
     * @param key key
     * @param object value
     * @return json字符串
     */
    public static String generateJsonString(String key, Object object) {
        JSONObject jsonObject = new JSONObject();
        try {
            jsonObject.put(key, object);
        } catch (JSONException e) {
            e.printStackTrace();
        }
        return jsonObject.toString();
    }

    /**
     * 判断是否是weekly包
     *
     * @return 是否是weekly包
     */
    public static boolean isWeekly() {
        return TextUtils.equals(SearchBox.getPkgName(), WEEKLY_PACKAGE_NAME);
    }

    /**
     * 判断是否是daily包
     *
     * @return 是否是daily包
     */
    public static boolean isDaily() {
        return BuildConfig.IS_DAILY;
    }

    /**
     * 判断是否是preview包
     *
     * @return 是否是preview包
     */
    public static boolean isPreview() {
        return TextUtils.equals(SearchBox.getPkgName(), PREVIEW_PACKAGE_NAME);
    }

    /**
     * 是否是特殊版本
     *
     * @return 是否是特殊版本
     */
    public static boolean isSpecialVersion() {
        return isWeekly() || isDaily() || isPreview();
    }

    /**
     * 读取4位版本号
     *
     * @return 4位版本号
     */
    public static String readFourDotNumber() {
        Context context = SearchBox.getAppContext();
        String number = "";
        try {
            ApplicationInfo appInfo = context.getPackageManager().getApplicationInfo(
                    context.getPackageName(), PackageManager.GET_META_DATA);
            if (appInfo != null) {
                Bundle bundle = appInfo.metaData;
                if (bundle != null) {
                    number = bundle.getString("versionName");
                }
            }
        } catch (NameNotFoundException e) {
            e.printStackTrace();
        }

        return number;
    }

    /**
     * 读取分支名
     *
     * @return 分支名
     */
    public static String readBranchName() {
        Context context = SearchBox.getAppContext();
        String number = "";
        try {
            ApplicationInfo appInfo = context.getPackageManager().getApplicationInfo(
                    context.getPackageName(), PackageManager.GET_META_DATA);
            if (appInfo != null) {
                Bundle bundle = appInfo.metaData;
                if (bundle != null) {
                    number = bundle.getString("branchName");
                }
            }
        } catch (NameNotFoundException e) {
            e.printStackTrace();
        }

        return number;
    }

    /**
     * 读取versionName
     *
     * @return versionName
     */
    public static String readVersionName() {
        String name = "";
        Context context = SearchBox.getAppContext();
        try {
            PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
            return packageInfo.versionName;
        } catch (NameNotFoundException e) {
            e.printStackTrace();
        }

        return name;
    }

    /**
     * 读取versionName
     *
     * @return versionName
     */
    public static String readVersionCode() {
        String code = "";
        Context context = SearchBox.getAppContext();
        try {
            PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
            return packageInfo.versionCode + "";
        } catch (NameNotFoundException e) {
            e.printStackTrace();
        }

        return code;
    }

    /**
     * 强制调出系统软键盘，不需要传入archer view
     * @param context context
     * @param boolean forceShow : true代表强制弹出， false代表如果已经弹出了，再调用则取消
     */
    public static void forceToggleSoftInput(Context context, boolean forceShow) {
        InputMethodManager imm =
                (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        if (imm != null) {
            int flag = forceShow ? InputMethodManager.SHOW_FORCED : 0;
            imm.toggleSoftInput(flag, InputMethodManager.HIDE_NOT_ALWAYS);
        }
    }

    /**
     * 强制隐藏系统软键盘
     * @param context context
     * @param IBinder binder getWindow() binder
     */
    public static void forceHiddenSoftInput(Context context, IBinder binder) {
        InputMethodManager imm =
                (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
        if (imm != null) {
            imm.hideSoftInputFromWindow(binder, 0);
        }
    }

    /**
     * 主动加载js回调至H5页面。
     *
     * @param js 回调语句
     * @param params 回调所带参数
     * @param webView 当前WebView
     */
    public static void loadJavaScript(String js, String params, BdSailorWebView webView) {
        if (webView != null && !TextUtils.isEmpty(js) && !webView.isDestroyed()) {
            if (!js.startsWith("javascript:")) {
                js = "javascript:" + js + "('" + params + "')";
            }
            if (com.baidu.searchbox.home.feed.BuildConfig.DEBUG) {
                android.util.Log.d(TAG, "call javasript:" + js);
            }

            // NOTE(hechaohua)在android4.4以上的版本中可能会失败，建议使用evaluateJavascript函数
            if (!BdZeusUtil.isWebkitLoaded() && Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                WebView myWebView = (WebView) webView.getCurrentWebView().getWebView();
                if (myWebView != null) {
                    myWebView.evaluateJavascript(js, null);
                }
            } else {
                webView.loadUrl(js);
            }
        }
    }

    /**
     * 调启action
     * @param context context
     * @param action action
     * @return true:调启成功;false:调启失败
     */
    public static boolean invokeAction(Context context, String action) {
        if (NBSwitcher.SWITCH_COMMAND_VERIFY) {
            LocalLogTracker.store(TAG, "invokeAction:" + action);
        }
        if (!TextUtils.isEmpty(action)) {
            try {
                JSONObject actionJson = new JSONObject(action);
                if (actionJson != null && actionJson.has(ACTION_TYPE_COMMAND)) {
                    String actionType = actionJson.optString(ACTION_TYPE_COMMAND);
                    if (TextUtils.equals(actionType, ACTION_TYPE_VALUE)) {
                        String command = actionJson.optString(ACTION_DATA_COMMAND);
                        if (!TextUtils.isEmpty(command) && Utility.isCommandAvaliable(context, command)) {
                            return Utility.invokeCommand(context, command);
                        }
                    } else {
                        if (SearchBox.DEBUG) {
                            Log.i(TAG, "action type not equal to 1");
                        }
                        Toast.makeText(SearchBox.getAppContext(),
                                R.string.activity_not_found, Toast.LENGTH_SHORT).show();
                    }
                }
            } catch (JSONException e) {
                StatisticProcessor.addOnlyValueUEStatisticCache(SearchBox.getAppContext(),
                        StatisticConstants.PLUGIN_LIFEPLUS_INVOKE, action);

                e.printStackTrace();
            }
        }
        return false;
    }

    /*
     * 获取框前后台状态
     *
     * @return true:前台 false:后台
     */
    @PluginAccessable(methodName = "isAppInForeground", paramClasses = {})
    public static boolean isAppInForeground() {
        boolean status = SearchBox.isAppInForeground();
        if (DEBUG) {
            Log.e(TAG, "Searchbox foreground status = " + status);
        }
        return status;
    }

    /**
     * 获取需要的定位数据
     * @param locationInfo {@link SearchBoxLocationManager.LocationInfo}
     * @param sUseDebugLocation 是否使用测试数据
     * @return 卡片操作格式的定位json
     */
    public static JSONObject getCardLocationJson(SearchBoxLocationManager.LocationInfo locationInfo,
                                                 boolean sUseDebugLocation) {
        if (SearchBox.GLOBAL_DEBUG && sUseDebugLocation) {
            locationInfo.addressStr = "韩国济州特别自治道济州";
            locationInfo.province = "济州特别自治道";
            locationInfo.city = "济州";
            locationInfo.cityCode = "110145";
            locationInfo.coorType = "bd09";
            locationInfo.country = "韩国";
            locationInfo.countryCode = "110000";
            locationInfo.longitude = 1.4080805095242E7;
            locationInfo.latitude = 3936696.438818;
            locationInfo.radius = 341.0;
        }

        JSONObject loc = null;
        try {
            loc = new JSONObject();
            loc.put("addr", locationInfo.addressStr);
            loc.put("city", locationInfo.city);
            loc.put("city_code", locationInfo.cityCode);
            loc.put("coun", locationInfo.country);
            loc.put("coun_code", locationInfo.countryCode);
            loc.put("dist", locationInfo.district);
            loc.put("prov", locationInfo.province);
            loc.put("str", locationInfo.street);
            loc.put("str_num", locationInfo.streetNo);
            loc.put("longitude", locationInfo.longitude);
            loc.put("latitude", locationInfo.latitude);
            loc.put("radius", locationInfo.radius);
            loc.put("coor_type", locationInfo.coorType);
        } catch (JSONException e) {
            loc = new JSONObject();
        }

        return loc;
    }

}